valuealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kDitherIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDitherOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColors_ditherenableDitheringrawRgbarawStraightRgbarawUnmodifiedpngrgba8888bgra8888_image_debugStackwidthheight	_disposeddisposedebugDisposed
toByteDatadebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage_cachedFrameCount
frameCount_frameCount_cachedRepetitionCountrepetitionCount_repetitionCountgetNextFrame_getNextFramenonZeroevenOdd	intersectunionreverseDifference_constructor_clonefillType_getFillType_setFillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo_arcTo
arcToPoint_arcToPointrelativeArcToPoint_relativeArcToPointaddRect_addRectaddOval_addOvaladdArc_addArc
addPolygon_addPolygonaddRRect	_addRRectaddPath_addPath_addPathWithMatrixextendWithPath_extendWithPath_extendWithPathAndMatrixcloseresetcontains	_containsshift_shift	transform
_transform	getBounds
_getBoundscombine_opcomputeMetricspositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImagecompile_uniformFloatCount_samplerCount_init_shader_builder_floatUniforms_samplerUniforms	trianglestriangleStriptriangleFanpointslinespolygon	_recordersave	saveLayer_saveLayerWithoutBounds
_saveLayerrestoregetSaveCount	translatescale_scalerotateskewgetTransform_getTransformclipRect	_clipRect	clipRRect
_clipRRectclipPath	_clipPathgetLocalClipBounds_getLocalClipBoundsgetDestinationClipBounds_getDestinationClipBounds	drawColor
_drawColordrawLine	_drawLine	drawPaint
_drawPaintdrawRect	_drawRect	drawRRect
_drawRRect
drawDRRect_drawDRRectdrawOval	_drawOval
drawCircle_drawCircledrawArc_drawArcdrawPath	_drawPath	drawImage
_drawImagedrawImageRect_drawImageRectdrawImageNine_drawImageNinedrawPicture_drawPicturedrawParagraph
drawPointsdrawRawPoints_drawPointsdrawVertices_drawVertices	drawAtlasdrawRawAtlas
_drawAtlas
drawShadow_drawShadowtoImage_toImageapproximateBytesUsedisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8List	fromAsset_initFromAsset_debugDisposedencoded_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixelbytesPerPixelinstantiateCodec_instantiateCodecmessagestackE_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaintImageByteFormatPixelFormatImage_ImageImageDecoderCallback	FrameInfoCodecinstantiateImageCodecinstantiateImageCodecFromBufferdecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayerPathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgram_FragmentShader
VertexModeVertices	PointModeClipOpCanvasPicturePictureRecorderShadowImmutableBufferImageDescriptor	_Callback_Callbacker	_futurizePictureRasterizationExceptiontdartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintpragmafromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliasByteDataListfilledgrowablegetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmacreator_toNativeColorFilter_toNativeImageFilterfromEnvironmentdefaultValuetoStringStringBufferwritetoStringAsFixed
toByteDatawidgets
StackTracecurrent_handlesaddvoid	_disposedcontainsremoveisEmptydispose
StateErrorformatFuturerawRgbamaphandle_debugStacktoList__imageNativeFieldWrapperClass1	Uint8Listcallbackencodedbuffer
asByteDataSetgetNextFramecloneDurationimage	CompletersynccompleteError	ExceptioncompletewidthheightdurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinginstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPathfrom_clonenonZerolefttoprightbottomzeroradiusrotationlargeArc	clockwise
fromCircleFloat32List_getValue32matrix4fromLTRB_opextractPathIterableforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveTo
collectionIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowhashcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3ArgumentErrordatainnerouterinnerFilterouterFiltermirrorrepeateddecaldilateerode
hashValuescomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradial	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAnglepaint
ByteBuffer	microtaskspirv
debugPrintspvTranspileResult	transpileTargetLanguagesksluniformFloatCountsamplerCountCustomPainterfloatUniformssamplerUniforms_builder_floatUniforms_samplerUniformsdrawVerticestextureCoordinatescolorsindicesany
Uint16ListclipRectSceneendRecordingisRecording_canvascullRectlargest_objects_datasydoAntiAliasclipOpgetClipBoundsarcTostack	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraints_needsLayout_paintRSTransform
isNotEmptyscosssintxty
addPicturedrawPicture	_recorder	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleminshadowIndex_kColorDefaultconvertRadiusToSigma_initUripath
encodeFull_initFromAsset_length_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1IterableBaseIteratorImageFilterShader	ExceptionÿêÅ+¢¹Xq_ÍD÷í{*   	dart:coreÀËõ À©— <€†€¤€¥€¦€¶€Ç€È_¯‚ ‚P‚‚ïƒ-ƒ0ƒ~ƒ¤ƒ¥ƒå„
„[„¡„í…=…P…Q…p…£…ã…ò…ô…õ††L†††Ÿ† †Å†ü‡V‡e‡g‡h‡”‡Íˆˆlˆ{ˆ}ˆ~ˆ£ˆÚ‰2‰A‰C‰D‰p‰°‰²‰³‰ç‰ëŠ;Š‹ŠÚ‹‹‹6‹:‹F‹m‹©‹àŒŒŒ#ŒtŒÃ?COœäìğşU›©åëDj‘¶¼ZˆÔ‘!‘F‘b‘™‘š‘Ú‘à’-’=’b’‰’¯’µ’ø’ş“I“V“‹“­“Ï“ñ”” ”u”{” ”Ç”í•:•j•p•³•¹––?–u–«–á—#—$—R—X—€—†—®—Ô—û˜ ˜3˜4˜m˜s˜Â˜ä™™™G™M™™À™æ™çššKšLš…š³š´šì›››c›™›Ÿ›×›òœ"œ&œ'œpœ¸œ¾œöJ{€Ğı;T†Š‹ÔŸ
ŸŸHŸcŸ“Ÿ—Ÿ˜Ÿé   T n Ÿ £ ¤ â¡¡=¡]¡¡¢¡£¡î¡ô¢H¢f¢l¢ª¢È££C£€£¼£í£ñ£ò¤!¤'¤o¤²¤¸¥¥O¥¥Ô¥Ú¦'¦q¦¼§§V§¦§ó¨D¨q¨w¨Æ¨æ©©2©G©^©s©‚©ª©²©¿©Ö©øªª&ªjªªªî«0«;«C«I«M«N«‘«×«İ¬)¬p¬»­
­U­•­½­ü®®®B®h®Ÿ®¼®Ê¯¯Z¯¢¯«¯È¯ú°(°H°e°w°Â±±^±g±m±q±r±¿±Å±ğ²#²@²t²x²y²…²¨²È²Û³³³3³T³X³Y³e³‹³Œ³˜³æ³è³é´´ ´m´·´Ö´Úµ+µxµÇ¶¶e¶°¶ô¶ø·H·“·ä¸0¸~¸Ë¹¹]¹¬¹òººº_º¬ºö»H»•»æ¼'¼+¼R¼V¼¤¼å½6½ƒ½Ô¾#¾r¾¾‘¾Ÿ¾£¾î¾ÿ¿¿_¿r¿¸¿¹¿ıÀ @À @?À @EÀ @¢À @«À @¬À @ëÀ @ñÀ A@À AOÀ AUÀ AÀ A–À AñÀ AøÀ AùÀ B8À B>À B‰À BšÀ B À BâÀ BèÀ CCÀ CJÀ CKÀ CˆÀ CÀ CÜÀ D-À DJÀ DPÀ DÀ DËÀ DÑÀ E0À E;À E<À EzÀ E€À E©À E¯À EıÀ FÀ FbÀ FhÀ F·À FâÀ FíÀ FîÀ G6À GƒÀ GĞÀ GŞÀ GäÀ H#À H)À HvÀ H¾À HÎÀ HÔÀ I À I&À IƒÀ IŒÀ IÀ IÚÀ J(À JrÀ JxÀ J²À J¸À KÀ KWÀ K]À K©À K¯À LÀ LÀ LÀ LeÀ L¸À MÀ MÀ MMÀ MSÀ M À MñÀ M÷À NDÀ NJÀ N¨À N²À N³À OÀ OUÀ OŸÀ O¥À OàÀ OæÀ P8À P„À PŠÀ P×À PİÀ Q;À QEÀ QFÀ Q•À QµÀ Q»À R	À RÀ R_À R«À RßÀ RåÀ S0À SAÀ SGÀ S¦À S±À S²À TÀ TÀ T"À TpÀ TvÀ TÆÀ UÀ UAÀ UGÀ U’À U£À U©À VÀ VÀ VÀ VdÀ V˜À VÀ VëÀ VñÀ WLÀ WSÀ WTÀ W“À W™À WèÀ X4À XZÀ X`À X®À X´À YÀ YÀ YÀ YcÀ YiÀ Y¸À ZÀ ZÀ Z^À Z‡À ZÀ ZŞÀ ZäÀ [DÀ [JÀ [ZÀ [`À [¢À [êÀ \À \PÀ \gÀ \sÀ \tÀ \¼À \½À ]À ].À ]4À ]€À ]ÍÀ ]üÀ ^À ^SÀ ^ŸÀ ^ÅÀ ^ËÀ _À _jÀ _»À _ÁÀ `À `2À `8À `–À `œÀ `¬À `²À aÀ aÀ a[À awÀ aÁÀ aØÀ aûÀ aüÀ bEÀ btÀ bzÀ bËÀ cÀ cjÀ c‰À cÀ cÛÀ d(À dWÀ d]À d¼À dÂÀ dÒÀ dØÀ eÀ eXÀ e¨À eÓÀ eŞÀ eßÀ f-À fLÀ fRÀ f›À f¬À f²À gÀ gÀ gÀ gjÀ g‰À gÀ gØÀ géÀ gïÀ hNÀ hYÀ hZÀ h•À h›À hçÀ i4À icÀ iiÀ iËÀ iÙÀ iÚÀ j-À j3À jÀ jÌÀ jûÀ kÀ kbÀ koÀ kpÀ k¹À kãÀ kéÀ l9À l‚À lĞÀ lıÀ mÀ mOÀ mœÀ mËÀ mÑÀ n2À n8À nHÀ nNÀ n‡À nÎÀ oÀ oIÀ oVÀ oWÀ o¥À o½À oÃÀ pÀ pÀ plÀ prÀ p‚À pˆÀ pÁÀ pÎÀ pÏÀ qÀ qÀ qmÀ q„À qŠÀ qÓÀ qäÀ qêÀ r"À r(À rŠÀ r˜À r™À råÀ róÀ rùÀ sHÀ s_À seÀ s®À s¿À sÅÀ sıÀ tÀ tdÀ tqÀ trÀ tÀÀ tÙÀ tßÀ u.À u}À uƒÀ uÏÀ vÀ vdÀ vjÀ v¹À vİÀ vãÀ wCÀ wlÀ wmÀ w¾À w×À wİÀ x&À x,À xuÀ xÅÀ xëÀ xñÀ yLÀ yRÀ ybÀ yhÀ y¸À yáÀ z0À zaÀ zhÀ ziÀ zºÀ zÓÀ zÙÀ {"À {rÀ {ŸÀ {¥À | À |À |À |À |^À |­À |ÃÀ |ÑÀ |ÒÀ }#À }<À }BÀ }‹À }‘À }ÚÀ ~*À ~_À ~eÀ ~ÂÀ ~ÈÀ ~ØÀ ~ŞÀ À bÀ °À ¹À ºÀ €À €$À €*À €sÀ €ÃÀ €ğÀ €öÀ XÀ ^À nÀ tÀ ÃÀ ÙÀ ‚$À ‚=À ‚KÀ ‚MÀ ‚NÀ ‚¦À ‚áÀ ‚åÀ ƒBÀ ƒ‰À ƒÀ ƒâÀ „6À „ŒÀ „àÀ „äÀ …2À …mÀ …qÀ …ÊÀ …ÎÀ †À †cÀ †‚À ††À †”À †˜À †ãÀ ‡À ‡2À ‡OÀ ‡jÀ ‡‰À ‡¨À ‡ÃÀ ‡ØÀ ˆ.À ˆVÀ ˆWÀ ˆ›À ˆ¡À ˆçÀ ‰,À ‰4À ‰5À ‰mÀ ‰sÀ ‰µÀ ‰äÀ ‰ëÀ ‰ìÀ Š6À Š^À ŠdÀ Š¯À ŠüÀ ‹EÀ ‹À ‹–À ‹ÆÀ ‹ÖÀ ‹ÜÀ Œ+À Œ_À ŒtÀ Œ~À ŒÀ ŒÏÀ ŒÜÀ ŒâÀ 0À mÀ sÀ šÀ  À òÀ BÀ À “À ÀÀ ÈÀ ÊÀ ËÀ ïÀ óÀ À À :À }À ºÀ ËÀ À À bÀ ÆÀ ÌÀ ‘À ‘LÀ ‘TÀ ‘UÀ ‘À ‘–À ‘àÀ ’0À ’ À ’¦À ’öÀ “À “$À “%À “hÀ “­À “ÒÀ “ØÀ ”'À ”˜À ”À ”îÀ •À •À •gÀ •‡À •‘À •“À •”À •¾À •ÂÀ –À –SÀ –WÀ –eÀ –iÀ –µÀ –ÁÀ –üÀ —:À —LÀ —‚À —ˆÀ —ñÀ —÷À ˜?À ˜À ˜›À ˜¡À ˜±À ˜·À ™À ™À ™gÀ ™ À ™©À ™ªÀ ™ßÀ ™åÀ šLÀ šRÀ ššÀ šêÀ šöÀ šüÀ ›À ›À ›`À ›qÀ ›zÀ ›{À ›ÉÀ ›ûÀ œÀ œhÀ œnÀ œ¶À À À À (À .À |À À –À ˜À ™À ÓÀ ×À îÀ -À BÀ “À ¡À ¢À èÀ Ÿ.À ŸUÀ Ÿ]À Ÿ^À Ÿ¢À ŸèÀ  /À  mÀ  wÀ  yÀ  zÀ  {À  ªÀ  ¶À  ÌÀ  ÒÀ ¡À ¡nÀ ¡tÀ ¡ÀÀ ¡ÖÀ ¢#À ¢|À ¢ÑÀ ¢êÀ ¢òÀ ¢óÀ £À £%À £~À £¯À £µÀ £õÀ £ûÀ ¤SÀ ¤®À ¤´À ¤ÄÀ ¤ÊÀ ¥&À ¥JÀ ¥VÀ ¥WÀ ¥vÀ ¥|À ¥ÈÀ ¥ÎÀ ¦!À ¦'À ¦nÀ ¦tÀ ¦ÉÀ ¦èÀ §?À §EÀ §UÀ §[À §£À §îÀ ¨À ¨|À ¨‰À ¨ŠÀ ¨ÖÀ ¨ÜÀ ©/À ©À ©ªÀ ©°À ªÀ ªOÀ ª¡À ªóÀ ªùÀ «IÀ «™À «çÀ ¬7À ¬}À ¬ƒÀ ¬“À ¬™À ¬çÀ ­À ­À ­À ­FÀ ­JÀ ­À ­¯À ­½À ­ìÀ ­ñÀ ®<À ®‡À ®ÖÀ ¯$À ¯sÀ ¯xÀ ¯ÈÀ °À °*À °/À °wÀ °xÀ °¬À °­À °ØÀ °ıÀ ±&À ±KÀ ±vÀ ±ŸÀ ±ÉÀ ±ùÀ ²&À ²PÀ ²„À ²´À ²àÀ ³À ³À ³JÀ ³€À ³¾À ³ôÀ ´6À ´tÀ ´´À µ À µFÀ µ†À µØÀ ¶"À ¶dÀ ¶œÀ ¶İÀ ·À ·À ·KÀ ·fÀ ·gÀ ·•À ·éÀ ·íÀ ·îÀ ¸À ¸?À ¸jÀ ¸¾À ¸¿À ¹À ¹À ¹)À ¹DÀ ¹ZÀ ¹`À ¹dÀ ¹eÀ ¹«À ¹¹À ¹¿À ¹×À ¹ğÀ º7À º;À º[À º«À ºÕÀ ºüÀ »@À »DÀ »EÀ »}À »­À »®À »çÀ »íÀ ¼À ¼À ¼#À ¼)À ¼oÀ ¼ À ¼èÀ ¼îÀ ½6À ½KÀ ½_À ½¨À ½ÔÀ ½ØÀ ½óÀ ¾À ¾DÀ ¾‚À ¾†À ¾‡À ¾¿À ¿ À ¿À ¿MÀ ¿SÀ ¿•À ¿æÀ À7À ÀXÀ À^À À«À ÀÌÀ ÀÒÀ ÀùÀ ÀÿÀ ÁÀ ÁÀ ÁdÀ Á˜À ÁâÀ ÁøÀ ÂÀ ÂaÀ ÂœÀ Â À ÂÃÀ ÂŞÀ ÃÀ ÃZÀ Ã^À Ã_À Ã£À Ã©À ÃÑÀ ÃíÀ Ä?À ÄCÀ ÄfÀ ÄÀ Ä¦À ÄäÀ ÄèÀ ÄéÀ Å#À ÅrÀ Å¯À ÅµÀ ÅòÀ ÆÀ ÆQÀ ÆUÀ ÆwÀ Æ’À Æ´À ÆúÀ ÆşÀ ÆÿÀ Ç@À ÇpÀ ÇvÀ Ç¨À ÇÄÀ ÈÀ ÈÀ È=À ÈXÀ È}À È¿À ÈÃÀ ÈÄÀ ÉÀ ÉÀ É\À É§À É­À ÉçÀ ÉíÀ ÊÀ ÊÀ ÊzÀ Ê€À ÊçÀ ÊíÀ ËTÀ ËZÀ Ë¦À Ë÷À ÌÀ Ì	À ÌÀ ÌÀ ÌnÀ ÌšÀ ÌãÀ Í"À Í@À Í”À Í˜À Í½À ÍØÀ ÍıÀ Î@À ÎDÀ ÎEÀ Î}À Î´À ÎµÀ Ï À ÏNÀ Ï™À ÏæÀ Ğ4À Ğ:À ĞÀ Ğ…À ĞÓÀ Ğ÷À ĞıÀ ÑfÀ ÑlÀ ÑÕÀ ÑÛÀ ÒDÀ ÒJÀ Ò–À ÒçÀ ÒóÀ ÒùÀ Ó	À ÓÀ ÓYÀ ÓtÀ Ó½À ÓİÀ Ô&À Ô*À ÔQÀ ÔlÀ ÔªÀ ÔõÀ ÔùÀ ÔúÀ ÕJÀ ÕˆÀ ÕÀ Õ²À ÕÑÀ ÖÀ Ö6À ÖKÀ ÖlÀ ÖŒÀ ÖçÀ ×.À ×9À ×?À ×PÀ ×TÀ ×zÀ ×“À ×åÀ Ø-À ØuÀ Ø‚À ØÏÀ ÙÀ ÙSÀ Ù¬À ÙıÀ ÚÀ ÚÀ ÚÀ ÚZÀ Ú®À ÚúÀ Û À Û(À ÛuÀ Û™À ÛóÀ Û÷À Ü"À Ü=À ÜbÀ Ü¨À Ü¬À Ü­À ÜçÀ ÜíÀ İ#À İ)À İ9À İ?À İ{À İ³À İåÀ Ş-À ŞDÀ ŞtÀ ŞxÀ Ş–À ŞÎÀ ŞÒÀ ŞÓÀ ßÀ ß,À ß2À ßWÀ ß]À ß®À ßÏÀ à&À àHÀ àLÀ àMÀ àuÀ à»À àÛÀ àùÀ á'À á/À á<À á‚À áˆÀ áŒÀ áÀ áÈÀ áÎÀ âÀ â/À â5À âCÀ âaÀ âgÀ â}À âƒÀ â°À âÊÀ âÛÀ âòÀ ã@À ãKÀ ãSÀ ã]À ãcÀ ãsÀ ãyÀ ã´À ãÕÀ ä,À äNÀ äRÀ äSÀ ä{À ä”À ä²À äàÀ äèÀ äõÀ å6À åŒÀ å·À åûÀ æÀ æ	À æÀ æÀ æMÀ æSÀ æŸÀ æéÀ çÀ ç4À ç{À çÀ ç À çêÀ çîÀ çïÀ èÀ èFÀ èJÀ èfÀ è«À è¯À è°À èèÀ èîÀ é:À é€À é³À é¹À éÿÀ ê À ê&À êsÀ ê¿À êâÀ êèÀ ë/À ë}À ë¤À ë¥À ë±À ëÇÀ ìÀ ì4À ì:À ìjÀ ì…À ì¡À ìÊÀ ìèÀ íÀ íBÀ íMÀ ípÀ í—À í¼À íèÀ î#À îxÀ î‡À î­À îµÀ îÍÀ îÓÀ îòÀ ï#À ï;À ïAÀ ïqÀ ï™À ï±À ï·À ïèÀ ğÀ ğ,À ğ2À ğQÀ ğÀ ğ¦À ğ¬À ğÊÀ ñÀ ñÀ ñ#À ñRÀ ñ“À ñ«À ñ±À ñËÀ ñşÀ òÀ òÀ ò;À òxÀ òÀ ò–À ò¬À òåÀ òöÀ ó*À óAÀ ó_À ócÀ óeÀ ófÀ ó¨À óÀÀ ôÀ ô[À ô£À ôíÀ õÀ õÀ õ!À õÀ õŠÀ õ‹À õ«À õ±À ö
À öÀ öÀ ö;À öAÀ ö‘À öÌÀ öİÀ öŞÀ öğÀ ööÀ ÷FÀ ÷”À ÷àÀ ø-À øvÀ ø|À øÍÀ øÙÀ øßÀ øïÀ øõÀ ùTÀ ù™À ù À ù¢À ù£À ùâÀ ùõÀ úCÀ ú“À ú©À úµÀ ú¶À ûÀ ûTÀ ûjÀ ûvÀ ûxÀ ûyÀ û¯À û³À ûóÀ û÷À üEÀ ü]À üaÀ ü°À üÿÀ ıFÀ ıÀ ıÜÀ ıêÀ ıîÀ ş:À ş‰À şĞÀ şÔÀ şâÀ şæÀ ÿTÀ ÿ£À ÿÉÀ À &À XÀ hÀ À £À ­À ÌÀ ĞÀ ÑÀ òÀÀ%À&ÀAÀBÀ†À™ÀšÀÜÀğÀñÀÀXÀ‰ÀÀàÀûÀÀLÀ—ÀæÀÀÀFÀrÀˆÀ¿ÀÔÀ÷ÀÀÀÀÀ^ÀdÀ²ÀÈÀãÀ÷ÀÀ#À6À@À®À²À³ÀèÀîÀ:ÀJÀPÀÀ¶ÀÀUÀŸÀëÀ	@À	mÀ	›À	ŸÀ	 À	ñÀ
À
À
YÀ
À
­À
½ÀÀ$À.ÀAÀEÀFÀwÀ}ÀÌÀÀlÀ¸ÀÀRÀÀ¼ÀÂÀÀ9À?À‡ÀØÀîÀôÀ*À0À>ÀYÀ_À—ÀÖÀõÀ?ÀPÀbÀ‚ÀÒÀ ÀFÀ|À‡À¨À°À¶ÀØÀÀWÀ‚ÀÅÀ	ÀFÀ_ÀeÀ¡ÀÑÀ×ÀôÀÀÀ6ÀTÀoÀwÀ}À™À¼ÀÂÀİÀãÀÀ?ÀIÀOÀzÀ‚ÀŒÀ’À×À%ÀIÀ[ÀpÀˆÀ³ÀÀRÀ”ÀÀ£ÀÂÀíÀñÀòÀ>À„ÀŠÀ×À!ÀqÀÀÀ
ÀWÀÀ‘ÀÀÇÀÉÀÊÀäÀÀ]ÀxÀ}ÀËÀíÀ	ÀÀÀ>À?ÀgÀhÀ½ÀóÀ1ÀaÀkÀsÀwÀxÀ´ÀÀÀ,À?ÀWÀcÀ{ÀÈÀàÀ*ÀbÀiÀÀÀ“À”À¾À¿ÀâÀãÀïÀ À !À "À TÀ À ‘À ÅÀ ÉÀ!À!À!#À!mÀ!¶À"À"JÀ"•À"¾À"ÂÀ"ûÀ"ÿÀ#À#À#NÀ#ŒÀ#ªÀ#÷À$BÀ$_À$«À$ÊÀ$ëÀ$ñÀ$ùÀ$ıÀ%À%À%#À%0À%gÀ%¥À%åÀ&$À&pÀ&ŠÀ&ÙÀ'!À'BÀ'HÀ'PÀ'bÀ'¬À'ÈÀ'ÎÀ(À((À(fÀ(gÀ(–À(œÀ(éÀ)À)À)À)/À)5À)}À)ƒÀ)ÏÀ)äÀ)æÀ)çÀ*À*À*SÀ*mÀ*qÀ*©À*ÆÀ*àÀ+À+À+]À+xÀ+}À+¶À+ÔÀ+ğÀ+ıÀ+şÀ,À,>À,yÀ,ªÀ,«À,ÊÀ,ùÀ,ÿÀ-3À-XÀ-¢À-İÀ-ŞÀ.À.À.PÀ.VÀ.§À.­À.îÀ/À/IÀ/‘À/åÀ0 À0uÀ0„À0¬À0èÀ1*À16À1>À1FÀ1_À1}À1ƒÀ1 À1¤À1¥À1áÀ2<À2=À2À2°À2ÙÀ2ÛÀ2ÜÀ2ÿÀ3À3RÀ3¢À3ğÀ4À4À4iÀ4·À4ğÀ4ôÀ5?À5‰À5ÙÀ6(À6tÀ6ÅÀ7À7\À7˜À7œÀ7æÀ80À8€À8¼À8ÀÀ9À9À9>À9RÀ9fÀ9{À9™À9¤À9ğÀ:À:&À:DÀ:dÀ:ˆÀ:À:À:À:³À:·À;À;VÀ;¤À;ÇÀ;ËÀ<À<mÀ<¦À<ªÀ<õÀ=?À=À=ŞÀ>*À>{À>ÊÀ?À?NÀ?RÀ?œÀ?æÀ@6À@rÀ@vÀ@ÃÀ@ÏÀ@şÀAÀA.ÀACÀAaÀAlÀA¸ÀAÑÀBÀB8ÀB>ÀB‚ÀBªÀB°ÀB´ÀBÈÀBîÀCÀC,ÀC1ÀC3ÀC4ÀC}ÀCÀCĞÀDÀDeÀD¯ÀDÜÀDŞÀDßÀEÀEdÀEÀE×ÀEôÀEöÀE÷ÀF4ÀF8ÀF†ÀFÑÀFéÀFíÀG9ÀGŠÀGÉÀGÍÀHÀHbÀH²ÀIÀIMÀIÀIíÀJ5ÀJqÀJuÀJ¿ÀK	ÀKYÀK•ÀK±ÀKÅÀKÒÀKàÀKöÀLÀL*ÀL>ÀLSÀLqÀLvÀL“ÀLÇÀLËÀLéÀMÀM#ÀM$ÀMLÀMqÀM¯ÀM¿ÀMÕÀMíÀN	ÀN&ÀN/ÀN0ÀNMÀN“ÀN½ÀNÇÀOÀO<ÀOFÀONÀOOÀO`ÀO{ÀOŸÀOÅÀOÏÀOíÀP1ÀPLÀPhÀPsÀP™ÀPµÀPÕÀPÖÀQÀQÀQÀQÀQÀQdÀQtÀQxÀQ¯ÀQÃÀRÀRÀRdÀR³ÀSÀS-ÀS3ÀSkÀSvÀSwÀS¹ÀS¿ÀTÀTaÀTgÀT ÀT«ÀT­ÀT®ÀTÒÀTÖÀTäÀTèÀU7ÀU]ÀUrÀU¦ÀU¬ÀUúÀVEÀV†ÀVŒÀVœÀV¢ÀVñÀWÀWÀWhÀWÀW”ÀWâÀX0ÀXJÀXPÀX`ÀX—ÀX¤ÀXïÀXõÀYCÀYÀYÃÀYÌÀZÀZPÀZVÀZ¤ÀZøÀZşÀ[À[KÀ[RÀ[†À[ŒÀ[ÚÀ\%À\fÀ\lÀ\|À\‚À\ËÀ\äÀ\ùÀ\ûÀ\üÀ]MÀ]gÀ]œÀ]æÀ^À^À^1À^2À^‚À^¥À^«À^ûÀ_DÀ_•À_ŞÀ_øÀ_şÀ`MÀ`™À`ÓÀaÀaÀaÀa7Àa;Àa€Àa„ÀaÇÀbÀbÀbÀbdÀbÀb“ÀbÒÀcÀc=ÀcAÀc…Àc¾ÀcØÀdÀd.ÀdJÀdgÀd˜Àd™ÀdçÀe,Àe8Àe9ÀeaÀegÀe´ÀfÀf&ÀfLÀfkÀf‚Àf†Àf·Àf¸ÀföÀfüÀgAÀg…ÀgÆÀgÇÀg÷Àh4Àh5ÀhjÀh¢Àh£ÀhëÀi5Ài6Ài}ÀiŠÀiÂÀiÃÀj
Àj<Àj†Àj‡ÀjÊÀk
ÀkÀkÀk€ÀkÃÀl
ÀlOÀl\ÀlÒÀlÓÀmÀm_ÀmnÀmÖÀm×ÀnÀncÀn¨Àn½Ào5Ào6Ào|ÀoÀÀpÀpLÀpqÀpÍÀpÎÀqÀqXÀqÀqäÀr*ÀrRÀr¾Àr¿ÀsÀs$Às*ÀsmÀs‘Às—ÀsŞÀtÀteÀt©ÀtğÀu4ÀubÀuhÀu­ÀuãÀv5ÀvUÀv´Àv¸ÀvüÀwWÀwXÀw§ÀwìÀwòÀxAÀxŠÀxÎÀxõÀxûÀyGÀy–ÀyâÀyèÀzÀz,ÀzGÀzbÀz}Àz„Àz¨ÀzÌÀ{À{6À{:À{}À{ÀÀ{ıÀ{şÀ{ÿÀ|NÀ|“À|™À|ÍÀ|ÓÀ}"À}pÀ}³À}ıÀ~À~MÀ~›À~èÀ~ÿÀ/ÀPÀkÀ†À¡À¨ÀÑÀõÀ€AÀ€yÀ€}À€ÈÀÀ>À{À|ÀÃÀÚÀöÀ‚À‚RÀ‚VÀ‚³À‚´À‚öÀƒ$Àƒ*Àƒ|ÀƒÊÀƒæÀ„À„BÀ„FÀ„£À„¤À„ìÀ…)À…hÀ…©À…ïÀ†3À†wÀ†ƒÀ†ÄÀ†äÀ‡7À‡;À‡€À‡ËÀ‡ÌÀˆÀˆ,Àˆ2ÀˆÀˆ¦Àˆ¬ÀˆóÀ‰(À‰DÀ‰vÀ‰zÀ‰ÇÀ‰ÈÀŠ
ÀŠMÀŠ]ÀŠ|ÀŠÀŠÂÀŠÆÀ‹À‹À‹IÀ‹OÀ‹œÀ‹êÀŒÀŒXÀŒ˜ÀŒ¼ÀŒ×ÀŒÿÀ>ÀKÀwÀ}ÀÀÉÀ9À:À€À¿ÀüÀÀOÀ ÀËÀÀUÀyÀ”À¼À‘À‘À‘AÀ‘GÀ‘KÀ‘¡À’À’À’cÀ’¤À’ÈÀ’ÉÀ“À“RÀ“mÀ“‘À“’À“âÀ”/À”NÀ”TÀ”œÀ”¢À”çÀ•À•*À•TÀ•XÀ••À•–À•ÖÀ–À–#À–GÀ–gÀ–À– À–¤À–ëÀ–ìÀ—,À—\À—„À—ªÀ—ÊÀ—éÀ—úÀ—şÀ˜LÀ˜MÀ˜‚À˜ˆÀ˜ØÀ™%À™pÀ™¯À™µÀšÀšUÀš§ÀšôÀ›>À›ŒÀ›šÀ›ßÀ›ôÀœÀœ]ÀœaÀœ•Àœ–ÀœâÀœõÀœûÀKÀ™ÀÓÀÀ7ÀRÀpÀ£À¶À¼ÀŸ3ÀŸ7ÀŸ{ÀŸ|ÀŸËÀŸüÀ À NÀ –À åÀ¡4À¡~À¡¶À¡¼À¢À¢TÀ¢À¢ÑÀ¢×À£'À£tÀ£ÄÀ¤À¤TÀ¤¡À¤ğÀ¥@À¥À¥•À¥ãÀ¦2À¦fÀ¦lÀ¦½À§À§CÀ§pÀ§tÀ§vÀ§wÀ§¹À§½À§ËÀ¨)À¨9À¨jÀ¨pÀ¨–À¨ÂÀ¨âÀ© À©À©FÀ©LÀ©¡À©ÍÀª
ÀªRÀªVÀªWÀªvÀª|ÀªÏÀ«À«,À«-À«ZÀ«`À«±À¬À¬À¬6À¬7À¬gÀ¬mÀ¬½À­À­(À­.À­|À­ËÀ®À®hÀ®yÀ®¾À®÷À®ùÀ®úÀ¯BÀ¯FÀ¯—À¯ãÀ°)À°-À°sÀ°wÀ°ÃÀ±À±0À±4À±~À±ÎÀ±ïÀ²/À²^À²¥À²¦À²ÎÀ²ÏÀ²ÛÀ³À³À³À³_À³yÀ³´À³şÀ³ÿÀ´À´7À´8À´DÀ´_À´’À´³À´ËÀµ.ÀµŠÀµşÀ¶À¶À¶'À¶+À¶,À¶8À¶LÀ¶sÀ¶£À¶¶À¶¼À¶ÔÀ¶æÀ¶êÀ¶ìÀ¶íÀ·,À·0À·xÀ·ÃÀ¸À¸5À¸9À¸‡À¸ÖÀ¹"À¹rÀ¹ÀÀ¹ÎÀ¹áÀ¹ÿÀºÀº]ÀºŸÀºÒÀºÓÀ»	À» À»!À»FÀ»LÀ»šÀ»àÀ¼0À¼OÀ¼fÀ¼gÀ¼’À¼˜À¼èÀ½/À½}À½ÌÀ¾À¾À¾YÀ¾©À¾øÀ¿1À¿KÀ¿LÀ¿kÀ¿lÀ¿mÀ¿½À¿äÀ¿êÀÀ9ÀÀ†ÀÀÀÀ¤ÀÀÙÀÀßÀÁ%ÀÁWÀÁ˜ÀÁœÀÁÀÁæÀÁìÀÂ.ÀÂrÀÂÀÀÃÀÃ!ÀÃ"ÀÃ.ÀÃ—ÀÃ™ÀÃšÀÃĞÀÃşÀÄ#ÀÄ'ÀÄzÀÄ{ÀÄŸÀÅÀÅ7ÀÅ;ÀÅ~ÀÅÀÅÃÀÆ9ÀÆ|ÀÆ·ÀÆÓÀÆæÀÆóÀÇ	ÀÇ/ÀÇTÀÇ]ÀÇcÀÇgÀÇÃÀÇÄÀÈ$ÀÈšÀÈºÀÉÀÉÀÉ#ÀÉ±ÀÉ²ÀÉÖÀÊLÀÊpÀÊtÀÊ¶ÀÊ·ÀÊâÀÊçÀË<ÀËfÀË~ÀËªÀËºÀË×ÀËİÀËîÀËòÀÌ0ÀÌ1ÀÌ}ÀÌƒÀÌÄÀÌäÀÌæÀÌçÀÍÀÍXÀÍiÀÍ¡ÀÍ¢ÀÍïÀÎ2ÀÎ<ÀÎ=ÀÎ‹ÀÎ×ÀÏÀÏÀÏÀÏ\ÀÏ­ÀÏğÀÏùÀÏúÀĞJÀĞXÀĞaÀĞcÀĞdÀĞ±ÀÑÀÑÀÑÀÑhÀÑ{ÀÑÆÀÑÌÀÒ ÀÒÀÒWÀÒ]ÀÒ¬ÀÒúÀÓJÀÓ[ÀÓaÀÓ°ÀÓ¶ÀÓÜÀÓâÀÓòÀÓøÀÔEÀÔ^ÀÔoÀÔ€ÀÔÀÔ¼ÀÔ½ÀÔ×ÀÔîÀÔïÀÕ%ÀÕpÀÕšÀÕĞÀÕÑÀÕİÀÖ ÀÖÀÖAÀÖdÀÖhÀÖiÀÖuÀÖ¨ÀÖ©ÀÖµÀ×À×À×	À×ZÀ×©À×÷ÀØCÀØtÀØxÀØÁÀØÎÀØùÀÙFÀÙ—ÀÙÛÀÙáÀÚ2ÀÚ€ÀÚ­ÀÚèÀÛ ÀÛ ÀÛ8ÀÛTÀÛUÀÛ£ÀÛéÀÛïÀÜ:ÀÜbÀÜhÀÜvÀÜ¥ÀÜÔÀİÀİ2ÀİaÀİkÀİqÀİÀÀŞÀŞÀŞÀŞ\ÀŞsÀŞŠÀŞ¡ÀŞ¸ÀŞÂÀŞÌÀŞÒÀŞäÀŞêÀßÀßÀßÀßYÀßuÀß‘Àß­ÀßÉÀßÓÀßİÀßãÀàjÀàpÀàzÀà·ÀàÚÀàıÀá ÀáCÀáMÀáWÀá]ÀáæÀáìÀáöÀâ7Àâ]ÀâƒÀâ©ÀâÏÀâÙÀâãÀãÀã*ÀãEÀã_Àã}Àã~ÀãÊÀãÚÀäÀäÀä4ÀäLÀäuÀävÀäÄÀäßÀåÀåÀå9ÀåQÀåzÀå{Àå’Àå±ÀåĞÀåãÀåäÀæÀæRÀæ–ÀæßÀç(Àç)ÀçJÀçVÀç£Àç¤ÀçÍÀçâÀçùÀè-ÀèDÀèNÀèvÀèÀè®ÀèÅÀèÏÀéÀéFÀéjÀéŸÀéÃÀéøÀêÀêIÀêOÀêSÀêTÀê`ÀêƒÀê­ÀêÁÀêáÀëÀë8ÀëZÀë…Àë‰ÀëŠÀë–ÀìÀìÀìÀì5ÀìJÀìaÀìšÀì³ÀìâÀíÀí8Àí\ÀíÀíÀíÂÀíÈÀíÌÀíÍÀíÙÀíïÀîÀîÀîTÀîmÀîœÀîÀÀîòÀïÀïHÀïWÀïôÀïúÀïşÀğ ÀğÀğ?ÀğCÀğ“ÀğŞÀñ0ÀñFÀñ|ÀñÀñ½ÀñõÀò	ÀòJÀòNÀòOÀòsÀò’ÀòÌÀòàÀóÀóÀóLÀókÀó°ÀóÄÀóâÀóæÀóçÀôÀô5ÀôzÀôÀô¬Àô°Àô±ÀôÿÀõ%ÀõBÀõCÀõ{ÀõÅÀöÀöYÀö¥Àö§Àö¨ÀöÛÀößÀöíÀöñÀ÷@À÷À÷ÜÀøÀøPÀø{Àø˜ÀøÔÀùCÀù_Àù{Àù™ÀùòÀùöÀù÷ÀúDÀúŠÀúÙÀúöÀûÀûVÀûZÀû[ÀûŸÀûñÀü?Àü\ÀüyÀü»Àü¿ÀüÀÀıÀı
ÀıXÀı¢ÀıÔÀş Àş=Àş`Àş~Àş¼ÀÿÀÿ"Àÿ#ÀÿmÀÿsÀÿÂÀÿùÀ À zÀ §À ïÀ óÀ ôÀEÀ’À¹ÀºÀÀ;À[À]À^ÀÀÛÀÜÀöÀÀÀ=ÀÀÀÄÀÅÀÑÀÀÀ!ÀeÀfÀrÀ•À¿ÀÓÀúÀ*À\À`ÀaÀmÀµÀ·À¸ÀğÀTÀUÀlÀƒÀÀŸÀ³ÀõÀÀ8À9ÀTÀkÀ–ÀÃÀôÀÀ%À)À*À6À€ÀÀÀØÀÙÀåÀ	À	2À	FÀ	sÀ	•À	·À	ŞÀ	âÀ	ãÀ	ïÀ
"À
$À
%À
WÀ
ŸÀ
 À
¸À
ĞÀ
ÑÀÀ!ÀXÀYÀeÀ¥À¦À²ÀóÀôÀ À#ÀMÀaÀˆÀ¬ÀÑÀÕÀÖÀâÀÀÀÀKÀ’À“À«ÀÃÀÄÀÀÀJÀKÀWÀ–À—À£ÀãÀäÀğÀÀ=ÀQÀwÀ›ÀÀÀÄÀÅÀÑÀÀÀÀ;ÀŒÀÀ®ÀÏÀĞÀíÀ3À?ÀvÀwÀƒÀíÀîÀúÀPÀQÀ]À€ÀªÀ¾ÀæÀÀ?ÀCÀDÀPÀÀÀÀÏÀÓÀ#ÀvÀºÀğÀ(À)ÀeÀšÀ¸ÀûÀÀSÀWÀ³À´ÀÀGÀxÀ–ÀÙÀíÀÀ"ÀvÀwÀ»ÀÀ<ÀZÀÀ±ÀáÀåÀ7À8À|À‚ÀĞÀÀKÀiÀ¬ÀÎÀÀ ÀZÀ^ÀºÀ»ÀíÀ À>ÀÀ•ÀÛÀ ÀÀ\À]ÀÀÄÀâÀ%À9ÀÀåÀ À #À ”À âÀ!À!%À!'À!(À!nÀ!£À!ÓÀ"À"9À"UÀ"cÀ"eÀ"fÀ"»À"ÔÀ"ØÀ#%À#sÀ#ÀÀ$À$À$iÀ$½À%À%nÀ%ÁÀ%êÀ%îÀ&HÀ&mÀ&qÀ&À&ƒÀ&ÇÀ'À'aÀ'‹À'ÕÀ(À(DÀ(‘À(ßÀ(ùÀ)4À)DÀ)À)¤À)ğÀ*6À*<À*”À*´À*ºÀ+À+€À+âÀ+ëÀ+ìÀ,=À,CÀ,›À,ùÀ-%À-+À-…À-âÀ-èÀ.NÀ.´À/À/%À/&À/yÀ/À/×À0/À0…À0 À0¦À1 À1VÀ1kÀ1qÀ1ÕÀ29À2œÀ2¦À2§À2çÀ2íÀ3GÀ3¢À3²À3¸À4À41À47À4šÀ4ıÀ5_À5hÀ5jÀ5kÀ5œÀ5ÄÀ5öÀ6À6>À6OÀ6QÀ6RÀ6†À6 À6ÈÀ7À7+À7IÀ7lÀ7À7³À7ÒÀ7ñÀ7õÀ8À8À8	À8FÀ8hÀ8ŠÀ8·À8ĞÀ8éÀ9À9À9,À9.À9/À9wÀ9{À9ÍÀ9àÀ9äÀ9òÀ9öÀ:lÀ:pÀ:À:‘À:ÆÀ:ÇÀ:üÀ;À;QÀ;¢À;ìÀ<!À<'À<vÀ<¬À<²À=À=xÀ=ÜÀ>BÀ>HÀ>“À>ÙÀ>ôÀ>úÀ?GÀ?šÀ?ÚÀ?íÀ?şÀ@À@'À@EÀ@mÀ@‡À@¬À@ÏÀ@îÀAÀAKÀA^ÀA‹ÀAÏÀBÀBtÀBˆÀBãÀBçÀC~ÀCÀCÊÀCêÀCğÀD?ÀDÀDÚÀEÀEÀEcÀE™ÀEŸÀFÀFeÀFÉÀG/ÀG5ÀG†ÀGÌÀGçÀGíÀH:ÀHÀHÍÀHÓÀIÀImÀI·ÀJÀJTÀJyÀJŒÀJŸÀJ²ÀJÌÀJêÀKÀK,ÀK?ÀK\ÀKƒÀK¢ÀKÃÀKÿÀLÀL?ÀL|ÀLäÀLåÀMJÀM¦ÀMêÀN ÀNjÀNwÀNàÀNöÀO‚ÀOˆÀOŒÀP;ÀQ#ÀQ$ÀQtÀQ’ÀQ˜ÀQãÀR1ÀRlÀRrÀRÁÀSÀS\ÀS‘ÀS—ÀSçÀT(ÀT.ÀTÀTòÀUUÀUºÀUÀÀVÀV_ÀV‚ÀVˆÀVÕÀW(ÀWhÀWzÀWÀW§ÀWÅÀWíÀX
ÀX-ÀXGÀXnÀXÀX®ÀXÑÀXòÀYÀYTÀYgÀY”ÀYÑÀZ9ÀZMÀZÂÀZÆÀ[‡À[ˆÀ[ÚÀ[øÀ\À\nÀ\{À\©À]À]À]À]À]À]PÀ]sÀ]ÃÀ^À^[À^¬À^ûÀ_PÀ_zÀ_–À_äÀ`À`À`OÀ`hÀ`À`À`®À`ÌÀa
ÀaÀa‘ÀaªÀaÈÀaÎÀaÒÀb
Àb”Àb–Àb—ÀcÀcÀcAÀc†ÀcŠÀdÀdÀd?Àd@Àd„ÀdŠÀdØÀe'ÀeQÀeWÀeÓÀfÀfCÀfbÀfÀf†ÀfÙÀg.Àg›ÀgŸÀg Àg¼ÀgÒÀgñÀhÀhÀh)Àh_ÀhlÀh‹Àh’ÀhµÀhèÀiÀiÀiÀi;Ài[Ài\Ài˜ÀiâÀiãÀj.ÀjHÀjNÀj™ÀjÍÀjÓÀkÀk^ÀkdÀkµÀkÿÀl8Àl>ÀlqÀlwÀlÀl®ÀlÚÀmÀm4Àm>ÀmDÀm“ÀmÜÀmâÀn@ÀnFÀnqÀnwÀn‚Àn’Àn¥ÀnàÀnæÀoAÀo„ÀoŠÀo½ÀoÃÀoÍÀoşÀp/Àp9Àp?ÀpˆÀp”ÀpšÀpåÀq"Àq4ÀqTÀq|ÀqƒÀq¤ÀqÛÀqáÀrÀr2Àr¦Àr¬ÀsÀs_ÀseÀsˆÀs±Às¾ÀsùÀsÿÀt3ÀtxÀt­ÀtÀÀtÄÀtÅÀtÕÀtñÀuÀu7Àu\Àu^Àu_ÀuyÀu ÀuéÀvÀvÀvIÀv\ÀvoÀvˆÀv£Àv´ÀvµÀv×ÀvûÀw'Àw(Àw4ÀwWÀwwÀwŠÀw´ÀwÈÀwìÀxÀxWÀx¦ÀxªÀx«Àx·Ày&Ày(Ày)ÀyzÀy~Ày¡ÀyèÀyúÀzBÀzOÀzPÀzÀz¯Àz°À{À{À{!À{"À{ZÀ{ŒÀ{ÓÀ{ÙÀ|À|bÀ|hÀ|¹À|âÀ|èÀ}#À}LÀ}‚À}ÍÀ}ÓÀ~ À~JÀ~À~›À~°À~ÎÀ~ôÀÀ%ÀBÀeÀºÀ€À€NÀ€™À€ìÀHÀIÀÀßÀ‚À‚À‚NÀ‚oÀ‚}À‚´À‚ÙÀ‚çÀ‚èÀƒVÀƒ˜ÀƒœÀƒÀƒíÀ„!À„]À„—À„ØÀ„ŞÀ…À…À…[À… À…»À…ÁÀ†À†[À†nÀ†©À†ÒÀ‡À‡SÀ‡YÀ‡ªÀ‡õÀˆÀˆÀˆOÀˆyÀˆ¾ÀˆÎÀˆãÀ‰ À‰%À‰<À‰UÀ‰rÀ‰•À‰êÀŠAÀŠ‚ÀŠÍÀ‹ À‹|À‹}À‹ÏÀŒÀŒÀŒÀŒ9ÀŒPÀŒtÀŒ¢ÀŒÂÀŒüÀŒşÀŒÿÀMÀQÀrÀ¶ÀÇÀéÀïÀ=À‡ÀÀÀÆÀÀbÀxÀ‚ÀƒÀ½ÀÃÀ	ÀÀQÀgÀpÀqÀ¦À¬ÀîÀ‘À‘À‘À‘À‘\À‘hÀ‘lÀ‘‹À‘™À‘ÑÀ‘ßÀ‘àÀ’À’&À’(À’)À’^À’bÀ’©À’íÀ“.À“2À“{À“ËÀ”À”1À”5À”…À”ÎÀ•À•À•TÀ•“À•ÃÀ–À–$À–*À–sÀ–»À—À—ZÀ—§À—êÀ—ğÀ˜7À˜MÀ˜iÀ˜½À˜ÛÀ™8À™RÀ™qÀ™À™êÀ™îÀšÀš=Àš]ÀšÀš¿ÀšÀÀ›À›zÀ›¿À›İÀ›ŞÀœ&Àœ,ÀœXÀœ^ÀœnÀœtÀœÅÀœúÀÀÀpÀÁÀÀYÀhÀnÀºÀŸÀŸYÀŸ¡ÀŸïÀ 9À ?À ŒÀ ’À ¶À ¼À¡
À¡VÀ¡¦À¡öÀ¢À¢!À¢oÀ¢¸À£	À£WÀ£¥À£õÀ¤=À¤jÀ¤pÀ¤ºÀ¤ÓÀ¤ÙÀ¤çÀ¥À¥<À¥SÀ¥“À¥¼À¥óÀ¦,À¦FÀ¦`À¦hÀ¦rÀ¦xÀ¦ÇÀ§À§cÀ§À§‡À§•À§ÂÀ¨À¨-À¨DÀ¨„À¨»À¨ôÀ©À©À© À©&À©wÀ©½ÀªÀªÀªÀªHÀª_Àª³ÀªìÀ«À«À«~À«·À«ÑÀ«ÙÀ«ãÀ«éÀ¬4À¬}À¬ÎÀ­À­À­0À­6À­uÀ­{À­ÉÀ®À®hÀ®³À¯À¯PÀ¯›À¯æÀ°7À°ˆÀ°£À°©À°¹À°¿À±À±1À±yÀ±À±½À±ØÀ±òÀ².À²;À²_À²¦À²ÕÀ²ÛÀ²ßÀ³/À³]À³|À³šÀ³ºÀ³ÛÀ´
À´KÀ´LÀ´ŒÀ´«À´±À´ğÀ´öÀµDÀµˆÀµ²Àµ³ÀµöÀ¶;À¶‚À¶·À¶½À¶âÀ·À·À·fÀ·¶À·øÀ·ùÀ¸HÀ¸’À¸£À¸©À¸ïÀ¹À¹@À¹AÀ¹|À¹}À¹ÒÀºÀº	ÀºZÀº¦ÀºõÀ»À»VÀ»WÀ»§À»âÀ¼
À¼'À¼EÀ¼ƒÀ¼œÀ¼ À¼âÀ¼ãÀ½6À½ŒÀ½¨À½®À¾ À¾NÀ¾À¾ËÀ¾êÀ¿À¿7À¿KÀ¿OÀ¿—À¿˜À¿æÀ¿ıÀÀÀÀGÀÀMÀÀŸÀÀçÀÁÀÁÀÁ`ÀÁtÀÁĞÀÁğÀÂÀÂ-ÀÂ…ÀÂ‰ÀÂ§ÀÂÄÀÂãÀÃÀÃ ÀÃ]ÀÃ^ÀÃ¬ÀÃËÀÃÑÀÄÀÄÀÄmÀÄµÀÅÀÅ@ÀÅbÀÅƒÀÅµÀÅ¹ÀÆÀÆÀÆZÀÆnÀÆtÀÆ¸ÀÆ¾ÀÇÀÇXÀÇÀÇ¹ÀÇùÀÈÀÈ<ÀÈ@ÀÈˆÀÈ‰ÀÈÚÀÉ,ÀÉÀÉÀÉ–ÀÉêÀÊ=ÀÊÀÊŞÀË-ÀË€ÀËÓÀÌ"ÀÌsÀÌÀÌ•ÀÌÍÀÍÀÍsÀÍÂÀÎÀÎ
ÀÎXÀÎÀÎ…ÀÎ“ÀÎ¬ÀÎæÀÏ$ÀÏ=ÀÏxÀÏµÀÏ¿ÀÏÅÀĞÀĞbÀĞ¸ÀÑÀÑÀÑ"ÀÑhÀÑµÀÑéÀÑïÀÒ?ÀÒÀÒÚÀÒòÀÓÀÓ%ÀÓTÀÓuÀÓ»ÀÓ¿ÀÔÀÔÀÔdÀÔ¶ÀÕ	ÀÕÀÕ_ÀÕ±ÀÖÀÖQÀÖ£ÀÖ÷À×JÀ×WÀ×]À×’À×¶À×åÀØÀØRÀØVÀØµÀØ¶ÀØùÀÙEÀÙbÀÙ—ÀÙ²ÀÙÑÀÙÿÀÚÀÚJÀÚKÀÚšÀÚâÀÚèÀÛ6ÀÛkÀÛ‹ÀÛ«ÀÛÆÀÜÀÜÀÜ.ÀÜJÀÜfÀÜ‚ÀÜ°ÀÜïÀÜğÀİÀİ%ÀİjÀİ…Àİ¥ÀİÀÀİíÀİñÀŞOÀŞPÀŞ ÀŞÛÀßÀß%Àß@Àß|Àß¨Àß¬ÀßÊÀßçÀàÀà&ÀàTÀà“Àà”ÀàåÀá'ÀáTÀávÀá‘ÀáÓÀá×ÀáüÀâ+ÀâlÀâmÀâ½ÀãÀã3Àã9Àã~Àã¹ÀãÛÀãıÀäÀäpÀätÀäšÀäÀÀäğÀå3Àå4ÀåÀåÒÀåõÀæÀæ?ÀæZÀæ–ÀæÂÀæÆÀæäÀçÀç Àç@ÀçnÀç­Àç®ÀçùÀèKÀèšÀè½Àè÷ÀéÀé1ÀésÀéwÀé”Àé±ÀéÓÀêÀêFÀêGÀêƒÀê‰ÀêÉÀëÀë`Àë´ÀìÀìUÀìÀì‡ÀìßÀí>Àí^ÀíyÀíÀÀîÀîÀî#Àî?Àî]Àî|ÀîŸÀîÂÀîâÀïÀïLÀïMÀï‚ÀïˆÀïÑÀğÀğFÀğpÀğ°ÀğËÀğıÀñÀñÀñKÀñŠÀñ‹ÀñÙÀò0ÀòlÀò®ÀòÒÀòíÀóoÀóˆÀóÖÀóÜÀóàÀôÀô"ÀôAÀôsÀôœÀôäÀôåÀõ4Àõ€Àõ†ÀõÕÀõîÀõôÀö@Àö‰ÀöœÀöáÀ÷#À÷BÀ÷aÀ÷|À÷³À÷æÀøÀøLÀøÀø´ÀøæÀùÀùOÀùˆÀù¾ÀúÀúÀújÀúpÀútÀú›ÀúÄÀúìÀûÀûAÀûjÀû’Àû¼ÀûçÀüÀüJÀüšÀü›ÀüâÀüèÀı6Àı„ÀıÑÀşÀşaÀşgÀşµÀÿÀÿPÀÿ—Àÿ¨ÀÿğÀ 2À TÀ sÀ À ÅÀ ûÀ0ÀgÀŸÀÒÀÀ8ÀmÀ¦ÀÜÀ!À:ÀˆÀÀ’À¹ÀåÀÀ=ÀkÀ”À¼ÀæÀÀGÀtÀÄÀÅÀÀ%ÀKÀ‘À¬À°ÀòÀóÀ?ÀOÀUÀ À­À³ÀÿÀLÀŠÀÀßÀ	+À	1À	‚À	ÏÀ
À
"À
lÀ
¸ÀÀ@À_ÀƒÀ¨ÀÚÀŞÀßÀ$À*ÀqÀwÀ‡ÀÀİÀöÀAÀ`À|À—ÀğÀôÀõÀ:À@ÀÀİÀãÀóÀùÀGÀeÀ²ÀÑÀíÀÀ(ÀsÀºÀ¾À¿ÀïÀÀ8À{À|À¯ÀµÀúÀ<ÀŠÀÂÀÀLÀmÀ’ÀâÀÀÀDÀJÀZÀ«À÷ÀÀpÀ»À¼ÀÀÀ>À‰ÀÀµÀÙÀÀRÀSÀ—ÀÀîÀGÀšÀîÀ&À,À|ÀÍÀÀnÀ¾ÀÀ^ÀdÀµÀÀZÀ±ÀáÀ5ÀƒÀÇÀÍÀ ÀoÀºÀÀ]ÀcÀ·À À QÀ WÀ ¨À ÃÀ ÉÀ ×À ìÀ ÿÀ!À!/À!7À!=À!kÀ!ÄÀ!âÀ"À"	À"À"JÀ"kÀ"¢À"ĞÀ"úÀ#À#5À#rÀ#À#®À#ôÀ$ À$LÀ$]À$rÀ$ À$ãÀ%
À%À%À%&À%.À%8À%>À%—À%À%«À%ÀÀ%ÓÀ%ëÀ&À&À&/À&7À&=À&kÀ&ÄÀ&âÀ'À'	À'À'JÀ'kÀ'¢À'ĞÀ'úÀ(%À(AÀ(~À(œÀ(ºÀ) À),À)XÀ)iÀ)~À)¬À)ïÀ*À*3À*gÀ*“À*À*£À*¯À*·À*ÁÀ*ÇÀ+À+[À+À+”À+¤À+ªÀ+øÀ,À,-À,\À,À,¥À,ÌÀ,íÀ-À-OÀ-oÀ-ŠÀ-ÍÀ-èÀ-éÀ.À.9À.„À.ÏÀ/7À/8À/À/¾À/¿À/éÀ0	À0.À0SÀ0xÀ0®À0ĞÀ0òÀ1(À1^À1’À1ÆÀ1ìÀ2À28À2`À2fÀ2gÀ2ĞÀ3À3IÀ3JÀ3pÀ3ÏÀ4À4À4À46À4„À4ŠÀ4À4À4ÓÀ4ÙÀ5*À5ƒÀ5ÖÀ6*À6|À6ÎÀ7À7À7[À7£À7©À7úÀ8:À8eÀ8kÀ8¹À9À9	À9UÀ9¢À9òÀ9øÀ:SÀ:dÀ:jÀ:xÀ:À: À:¸À:ĞÀ:ØÀ:ŞÀ;À;eÀ;ƒÀ;¤À;ªÀ;¼À;ëÀ<;À<ŠÀ<ÛÀ<÷À=<À=†À=¾À=úÀ>#À>JÀ>zÀ>¢À>¨À?À?\À?¶À?øÀ@$À@PÀ@À@ÊÀ@ÖÀ@÷ÀARÀA\ÀAbÀAnÀAvÀA€ÀA†ÀAßÀAåÀAóÀBÀBÀB3ÀBKÀB^ÀBwÀBÀB…ÀB³ÀCÀC*ÀCKÀCQÀCcÀC’ÀCâÀD1ÀD‚ÀDÀDãÀE-ÀEkÀE£ÀEßÀFÀF/ÀF_ÀF‡ÀFÀFèÀG?ÀGšÀG÷ÀHBÀHˆÀH±ÀHËÀIÀI"ÀI>ÀI‚ÀI¬ÀIÖÀIåÀJÀJSÀJˆÀJ½ÀJÃÀKÀKwÀKÏÀLÀLEÀLQÀLrÀLİÀLçÀLíÀLùÀMÀMÀMÀM!ÀM'ÀMtÀM‰ÀMªÀMÙÀN ÀN'ÀNQÀNuÀN˜ÀNÚÀNıÀOÀOIÀOdÀOeÀOÀO¸ÀPÀP"ÀP€ÀPºÀQ3ÀQkÀQlÀQ’ÀQçÀR1ÀR8ÀR9ÀRRÀR ÀR¦ÀRªÀR«ÀRİÀSÀS3ÀSVÀS†ÀS®ÀSÖÀSúÀTAÀTBÀTÀT•ÀTåÀTúÀU ÀU&ÀU~ÀU¾ÀUÙÀVÀVFÀVJÀVhÀV†ÀV«ÀVôÀVöÀV÷ÀW?ÀWCÀWwÀW{ÀWÂÀXÀXFÀX`ÀX‘ÀXÛÀX÷ÀXıÀY3ÀYOÀY^ÀY_ÀY‰ÀYÀYŞÀZ-ÀZvÀZ§ÀZ¿ÀZâÀ[À[,À[|À[™À[³À[ÄÀ\À\À\À\À\"À\ƒÀ\„À\ÔÀ\÷À]
À]"À]2À]JÀ]]À]gÀ]wÀ]{À]|À]¨À]©À]ªÀ]ÄÀ^
À^À^^À^tÀ^À^£À^³À^ÏÀ^âÀ^ìÀ_\À_`À_aÀ_ªÀ_°À`À`3À`vÀ`xÀ`yÀ`ÀÀ`ÄÀa	ÀaNÀa‡ÀaÈÀbÀb+ÀbGÀboÀb«Àb¬ÀbçÀbíÀc1ÀcxÀc¯ÀcôÀd0Àd[Àd\Àd‹Àd‘ÀdÜÀe,ÀeqÀeŒÀe¥ÀeéÀfÀf.ÀfMÀfaÀfuÀfyÀfzÀfÊÀfËÀfŞÀfàÀfáÀföÀfúÀg6ÀgEÀg_ÀgeÀg°ÀgûÀhÀhÀh\ÀhbÀh±ÀhÊÀhÛÀi	Ài(ÀiCÀi€Ài¿ÀjÀjÀjEÀjiÀj“Àj¾ÀjåÀkÀk6Àk7ÀkgÀkmÀk¿ÀkâÀk÷ÀkøÀl7Àl=Àl‹Àl×ÀmÀm0Àm1ÀmƒÀmÀmŸÀmÑÀm×Àn
ÀnÀn=Àn°ÀnæÀoÀoÀoÀo[ÀoaÀo”ÀoĞÀoÑÀpÀp$ÀpaÀp°Àp×ÀpİÀq!ÀqjÀq¹ÀqÛÀqïÀrÀrÀr[Àr_Àr`Àr²ÀrÀÀràÀróÀsÀs&ÀsMÀsTÀsXÀsYÀs‰ÀsÀsÚÀtÀtCÀtIÀtoÀt¼ÀuÀuQÀuÀuëÀv;ÀvˆÀvÌÀvÒÀw!ÀwAÀwVÀwÀw¥ÀwºÀwÑÀwæÀwõÀxÀxÀx+ÀxBÀx]ÀxlÀxƒÀx¶ÀxíÀy/Ày:ÀyBÀyHÀyLÀyMÀy†ÀyŒÀyÔÀyÚÀyıÀzKÀzbÀz‚Àz•Àz«ÀzÁÀzíÀ{(À{VÀ{…À{ºÀ{áÀ|À|7À|JÀ|NÀ|OÀ|[À|~À|À|±À|ÌÀ|ìÀ}À}9À}=À}>À}JÀ}ˆÀ}‰À}ÕÀ~'À~CÀ~}À~–À~°À~±À~îÀ$À%À?ÀŒÀ¾À€À€xÀ€œÀ€¸À€ïÀ€ğÀ+ÀtÀuÀ®ÀİÀŞÀ‚À‚FÀ‚GÀ‚˜À‚ÔÀ‚üÀƒÀƒ
ÀƒÀƒ#Àƒ'Àƒ(Àƒ4ÀƒwÀƒyÀƒzÀƒÁÀƒÅÀ„À„*À„cÀ„†À„‡À„ÕÀ„êÀ…+À…pÀ…¢À…ÈÀ…æÀ…êÀ…ëÀ†%À†+À†dÀ†¢À†çÀ‡0À‡zÀ‡§À‡ïÀˆ*Àˆ[Àˆ—ÀˆĞÀˆÔÀˆÕÀ‰+À‰,À‰—À‰˜À‰ÌÀ‰éÀ‰øÀ‰ùÀŠÀŠÀŠBÀŠHÀŠ™ÀŠ´ÀŠÌÀŠÜÀŠıÀ‹À‹À‹/À‹3À‹4À‹„À‹§À‹­À‹úÀŒDÀŒ‘ÀŒŞÀ,ÀJÀ]ÀmÀŒÀ©À¼ÀÆÀÖÀÚÀÛÀÀÀÀ]ÀaÀ°ÀÈÀÀÀÀdÀ§ÀãÀÀMÀmÀqÀàÀáÀ‘À‘ À‘pÀ‘ÂÀ‘ÜÀ‘âÀ’0À’ƒÀ’ÄÀ“À“À“6À“NÀ“gÀ“zÀ“ À“§À“»À“ÑÀ”À”.À”|À”€À•À• À•/À•aÀ•‹À•‘À•ÌÀ•÷À•øÀ–À–<À–gÀ–mÀ–¨À–ÖÀ–×À–îÀ—0À—bÀ—hÀ—ŸÀ—âÀ—ãÀ˜3À˜VÀ˜‰À˜ŠÀ˜ØÀ˜ôÀ˜úÀ™EÀ™’À™£À™©À™÷ÀšÀšoÀš¢Àš¼ÀšÂÀš÷À›À›À›À›PÀ›kÀ›ˆÀ›ÆÀœÀœ(ÀœfÀœ‡Àœ½ÀœÃÀœäÀÀÀ*ÀeÀwÀ{ÀòÀôÀõÀ*ÀZÀ[À“À—ÀáÀîÀŸ1ÀŸ2ÀŸ‚ÀŸ˜ÀŸœÀŸêÀ À À YÀ ]À pÀ tÀ €À µÀ ¹À ôÀ¡,À¡2À¡6À¡VÀ¡‡À¡À¡•À¡ğÀ¢LÀ¢~À¢²À¢èÀ£/À£sÀ£°À£ÄÀ£ğÀ¤À¤À¤DÀ¤SÀ¤“À¤›À¤¨À¤ÅÀ¤ËÀ¤ÑÀ¤áÀ¤öÀ¥À¥-À¥/À¥0À¥À¥«À¥¯À¥ÿÀ¦OÀ¦„À¦¿À§À§À§:À§RÀ§SÀ§¥À§ÀÀ§ÁÀ§ÍÀ§ãÀ¨=À¨VÀ¨nÀ¨µÀ¨ŞÀ¨äÀ©À©À©       $‰³ª4¡„ç/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c = const Color(0xFF42A5F5);
/// Color c = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c = const Color.fromARGB(255, 66, 165, 245);
/// Color c = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. «‚í ‘j‘o‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).‘p	‘u  
‘H‘I‘O‘`‘P‘ƒ‘}‘‹‘…‘‘œ‚‚“c“d“l£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.“m“r  “t“y  “{“€  “‚“‡  -“•“”“—”“ï“Í“«“˜“©“¤“™“¢“œ“š““§“º“Ë“Æ“»“Ä“¾“¼“À“É“Ü“ì“è“İ“æ“à“Ş“â“ë“ş””
“ÿ””” ””””"ƒ –––Ê/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.––  ––$  –&–+  –-–5  3–I–C—–K—–ß–©–s–L–q–l–M–j–d–N–b–^–W–O–Y–a–f–o–ƒ–§–¢–„– –š–…–œ–¥–¹–Ü–Ø–º–Ö–Ğ–»–Ò–Û–ï——–ğ——–ñ————&˜,€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. ˜6€Ü˜î€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   ™€Ï™Í€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   ™éaš(4/// The red channel of this color in an 8 bit value.   šNdš6/// The green channel of this color in an 8 bit value.   š¶bšö5/// The blue channel of this color in an 8 bit value.   ³[/³o   ³[³\›	›ß€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ›é›î   œ)Uœş€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. 
   ‚C€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. KP   	ŸP€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ŸZŸ_   Ÿš \€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects.  e j    ä€½ ò  ¡¡   ¡¥‚K¢³€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   £ô‡X¨ö„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. ¨û©  ©©  ©©   «P† ­dö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. ­o­v  ­­ˆ   ±t±ıw/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. ²²   ²{€Ü²•  ²˜²   ²{²|³W³¡   ³³ À ­À F`À ­µ€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À ¸Á€¢ À ¹À ¹$Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  'À °z0À °‰ À °‘À °™À °©À °šÀ °¯'À °À À °ÕÀ °Ú!À °ë À °úÀ °ÿ%À ± À ±#À ±(!À ±9 À ±HÀ ±M'À ±^ À ±sÀ ±x%À ±‰ À ±œÀ ±¡&À ±² À ±ÆÀ ±Ë,À ±Ü À ±öÀ ±û)À ² À ²#À ²(&À ²9 À ²MÀ ²R0À ²c À ²€À ²†,À ²— À ²°À ²¶(À ²Ç À ²ÜÀ ²â#À ²ó À ³À ³
>À ³ À ³DÀ ³1À ³GÀ ³L2À ³] À ³zÀ ³mÀ ³}À ³‚:À ³“ À ³¸À ³§À ³»À ³À2À ³Ñ À ³îÀ ³áÀ ³ñÀ ³ö>À ´ À ´0À ´À ´3À ´8:À ´I À ´nÀ ´]À ´qÀ ´v<À ´‡ À ´®À ´œÀ ´±À ´¶HÀ ´Ç À ´úÀ ´âÀ ´ıÀ µBÀ µ À µ@À µ+À µCÀ µH<À µY À µ€À µnÀ µƒÀ µˆNÀ µ™ À µÒÀ µ·À µÕÀ µÚFÀ µë À ¶À ¶À ¶À ¶$>À ¶5 À ¶^À ¶KÀ ¶aÀ ¶f4À ¶w À ¶–À ¶ˆÀ ¶™À ¶ß%À ¶ğ À ·À ·MÀ ·\  À ·ğ"À ¸ À ¸À ¸'À ¸' À ¸<À ¸A'À ¸R À ¸gÀ ¸l"À ¸} À ¸À »,À » À »¡À ¾Á=À ¾Ò À ¾çÀ ¾ğÀ ¾ñÀ ¾øÀ ¾ùÀ Î3À Î“ À Î¯À è²‚ğÀ ë‹‚®/// Whether to dither the output when drawing images.
///
/// If false, the default value, dithering will be enabled when the input
/// color depth is higher than the output color depth. For example,
/// drawing an RGB8 image onto an RGB565 canvas.
///
/// This value also controls dithering of [shader]s, which can make
/// gradients appear smoother.
///
/// Whether or not dithering affects the output is implementation defined.
/// Some implementations may choose to ignore this completely, if they're
/// unable to control dithering.
///
/// To ensure that dithering is consistently enabled for your entire
/// application, set this to true before invoking any drawing related code.À ëÀ ¹g€ÓÀ ¹âi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À º=À ºA  À ºM
À ºS   À »°‚'À ½W„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ½Ú€«À ½Ş  À ½äÀ ½ë   À ¿ƒœÀ Â‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Â¢€»À Â¦  À Â°À Â»   À Ãa€áÀ Ãåk/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À ÄE€¢À ÄI  À ÄOÀ Ä^   À ÄëiÀ Åÿ€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À ÆW€¦À Æ[  À ÆgÀ Æo   À ÇÀ Ç¸€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À È€¦À È   À È*À È5   À ÈÆ„ÑÀ Í3„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À Íš€©À Í  À Í©À Íµ   À Î·…rÀ ÓÊ„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Ô,€ÌÀ Ô0  À ÔAÀ ÔI   À Ôü‚WÀ ÕÄ€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À ×V‚°À ×Z  À ×eÀ ×r   À Ú
ìÀ Û‰/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Ûù€²À Ûı  À ÜÀ Ü   À Ü¯ÈÀ Ş;k/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À ŞzWÀ Ş~  À Ş…À Ş   À ŞÕvÀ ßÁ€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À àO<À àS  À à_À àm   À á‚ÂÀ ãÇú/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// import 'dart:ui' as ui;
///
/// ui.Image image;
///
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     image,
///     Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: .5, sigmaY: .5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À äU·À äY  À äeÀ äs   À ænÀ ç%/// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À çlÀ ç…  À ç’
À ç˜   À çñXÀ çú    À èLbÀ èP  À èX
À è^   À ·i€ƒÀ ·w    À ë§‡»À ëº   À ë§À ë¨ À ûyŸOÀ „/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À (€§À -À .À / À 0À 6  À =
À C  À IÀ O   À ô/À À ôÀ õÀ ûÀÀ üÀ(À4  ÀDSÀ’A/// The number of image pixels along the image's horizontal axis. ÀœRÀè?/// The number of image pixels along the image's vertical axis. ÀóÀø ÀÀ•ÀÓ€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   ÀƒÀæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   Àµ‚éÀÿ€ô/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. À	0À	  À	$À	3À	4À	¢¢À
m€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   ÀHŒ¨ÀQŠn/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageLoader(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   Àô‚›À^‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. ÀhÀo   À“3À¦   À“À” ÀÊ…VÀê  Àï'ÀÀÀ  ÀïÀğÀöÀÀ÷ÀÀ À%ÀÁÀÌ ÀŞÀßÀ×ÀİÀØÀ#À"    ÀA%ÀI    ÀjÀ|  Àˆ0À™  À¡À°À±Àz€–À¾9/// Returns an error message on failure, null on success. ÀÊ
ÀÏ  ÀÖÀí   À.dÀ3    À–'À›    Àå9Àø   ÀåÀæÀÊÀËÀÑÀâÀÒÀ ‘‰TÀ'V†¾/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(Codec codec) async {
///   final FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(Codec codec) async {
///   final FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À'dÀ(3À(4À(5€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À(7À(F  À(OÀ(^   À(i€™À(ú{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À)€ÚÀ)İ€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À)çˆóÀ*æ€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec]. À+Ö&À+÷À+øÀ+ù  À+ÖÀ+×À+İÀ+îÀ+ŞÀ, À,  À,­À,²  À,^À,H#/// Number of frames in this image.   À,{.À,ƒ    À,Ì€ÕÀ-b€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À-¤8À-¬    À-àƒÃÀ/2//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À1§€”À1ë9/// Returns an error message on failure, null on success. À1ù$À2   À2?€™À2·n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À*ÆÀ*ÇÀ*ÍÀ*ŞÀ*ÎÀ\ü„À]mP/// A handle for the framework to hold and retain an engine layer across frames. À]€’À^+À^,À^-a/// This class is created by the engine, and should not be instantiated
/// or extended directly. À^À^À^À^À^  À^4‚ÍÀ`Ú‚ˆ/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.   À]MÀ]NÀ]TÀ]eÀ]UÀaÀ FpÀcŞ‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. Àd^ ÀdLÀdP%/// Create a new empty [Path] object. Àd0Àd1Àd7ÀdHÀd8Àd›€œÀe2Àe3Àe4€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].  Àe;JÀfÀfÀf€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.ÀfÀf    Àfº€ÊÀgT€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   Àg‡>Àg‹  Àg”Àg¢   1Àdi.Àdn    Àfˆ.Àf  Àf”Àfš   ÀgÉ-ÀgÍ    Àgù:Àgş  ÀhÀh   Àh7jÀhq2/// Starts a new sub-path at the given coordinate. ÀhxÀh€  Àh‚ÀhŠ   Àh¥€ÀhòE/// Starts a new sub-path at the given offset from the current point. Ài	Ài	  Ài	Ài   Ài8€‰Ài‘O/// Adds a straight line segment from the current point to the given
/// point. Ài˜Ài   Ài¢Àiª   ÀiÅ€ÀÀjCt/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. ÀjR	ÀjZ  Àj]	Àje   Àj‰€õÀk €‹/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1). Àk2	Àk:  Àk=	ÀkE  ÀkH	ÀkP  ÀkS	Àk[   Àk‚OÀlc€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. Àl}	Àl…  Àlˆ	Àl  Àl“	Àl›  Àl	Àl¦   ÀlÕ Àmu€”/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2). Àm}	Àm…  Àmˆ	Àm  Àm“	Àm›  Àm	Àm¦  Àm©	Àm±  Àm´	Àm¼   ÀmÙ[ÀnÄ€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. ÀnÔ	ÀnÜ  Ànß	Ànç  Ànê	Ànò  Ànõ	Ànı  Ào 	Ào  Ào	Ào   Ào8”Àpx0/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse. Àp€	Àpˆ  Àp‹	Àp“  Àp–	Àp  Àp¡	Àp©  Àp¬Àp´   ÀpĞíÀrYw/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. Àri	Àrq  Àrt	Àr|  Àr	Àr‡  ÀrŠ	Àr’  Àr•Àr   ÀrÁƒöÀuêƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. Àuğ	Àuö  ÀuûÀv  ÀvÀv  Àv!Àv'   Àvº€œÀv¿  ÀvÆÀvÎ  ÀvÓ
ÀvÛ  ÀvßÀvç  ÀvíÀvõ  Àw
Àw  ÀwÀw%  Àw0Àw6   ÀwZƒßÀyï‚w/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// ÀyúÀz  ÀzÀz  Àz0Àz8  ÀzKÀzQ  ÀzfÀzl  ÀzÀz%Àz&ÀzBÀz[ÀzwÀ{<€ÀÀ{A  À{MÀ{U  À{]À{e  À{mÀ{u  À{À{˜  À{ À{¨  À{±À{·  À{ÓÀ{Ù   À|„{À‚ã/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. ÀÀ!  À3À;  ÀTÀ\  ÀoÀu  ÀŠÀ  ÀCÀIÀJÀfÀÀ›À€€ûÀ€„  À€˜À€   À€¨À€°  À€¸À€À  À€ãÀ€ë  À€óÀ€û  ÀÀ%  À.À4   À~€×ÀáY/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. Àé	Àï   À‚XZÀ‚]  À‚fÀ‚n  À‚s
À‚{  À‚À‚‡  À‚À‚•   À‚¶ÀƒÑ/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. ÀƒÙ	Àƒß   À„HZÀ„M  À„VÀ„^  À„c
À„k  À„oÀ„w  À„}À„…   À„¦‚”À†ŠÎ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval. À†‘	À†—  À†œÀ†¤  À†¯À†·   À‡=€À‡B  À‡JÀ‡R  À‡W
À‡_  À‡cÀ‡k  À‡qÀ‡y  À‡À‡—  À‡¢À‡ª   À‡Î«Àˆú/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. À‰À‰  À‰
À‰    À‰|JÀ‰  À‰À‰š  À‰¡
À‰§   À‰Ê€ûÀŠd€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. ÀŠmÀŠt   ÀŠÈ9ÀŠÍ  ÀŠ×ÀŠä   À‹‚{ÀŒ/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. ÀŒ$	ÀŒ*  ÀŒ/ÀŒ7  ÀŒ?ÀŒM   ÀƒEÀˆ  À‘	À—  Àœ	À¤  À§	À¯   ÀËmÀĞ  Àã	Àé  Àî	Àö  Àù	À  ÀÀ   À<ƒÀÒ‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. Àá	Àç  ÀìÀô  ÀüÀ
   À‘MSÀ‘R  À‘b	À‘h  À‘m	À‘u  À‘x	À‘€   À‘£yÀ‘¨  À‘Á	À‘Ç  À‘Ì	À‘Ô  À‘×	À‘ß  À‘âÀ‘ï   À’ €§À’«€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À’Ë€ÅÀ“t€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   À“”ÃÀ”îF/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. À”÷À”ÿ   À•Z:À•_  À•iÀ•q  À•sÀ•{   À•˜À–j/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. À–À–   À–¦DÀ–«  À–²À–¸  À–À	À–È  À–Ë	À–Ó   À–îÀ—ck/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. À—mÀ—z   À˜ KÀ˜  À˜À˜  À˜À˜+   À˜O„À›æƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   Àœc1Àœo    Àœ˜‚Àá0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. ÀéÀø  À
À  À
À   ÀŸ9AÀŸ>  ÀŸB
ÀŸH  ÀŸN
ÀŸT  ÀŸZÀŸ_   ÀŸ~‡õÀ§‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. À§&À§,  À§9Àc¾Àc¿ÀcÅÀcÖÀcÆÀ§w‡À¨/€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. À¨;€Ä À¨À¨¥V/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.À¨¦À¨¬  À¨µÀ¨»  À¨ÈÀ¨ÎÀ¨ßÀ¨ØÀ¨ÏÀ¨ÛÀ¨èÀ¨îÀ¨ıÀ¨öÀ¨ïÀ¨ùÀ©RÀ©ŞÀ©ßÀ©è€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.À©éÀ©ñ  À©úÀª   ÀªY€ÑÀ«"€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. À«/À¬.€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). À¬9‚½À®Ë‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     À®ú„À±õ‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. À²1sÀ²<À²=À²> À²?	À²E  À²JÀ²P  À²lÀ²bÀ²nÀ²€À²À²‚À²¢À²ƒÀ²À²¡À²À²–À²¨$À²Ã  À²Ñ;À²ö   À²ÑÀ²Ò  À³ƒÛÀ³h/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. À³¶GÀ³ÈÀ³ÉÀ³Ê À³ËÀ³Ñ  À³àÀ³æÀ³ûÀ³ôÀ³çÀ³÷À´À´  À´À´)  À´:ğÀ´U   À´:À´;À¶.€»À¶?   À¶.À¶/ À¶íŒ«À¹Ô‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. À¹ã€îÀ¹íÀ¹îÀ¹ï À¹ğÀ¹ö  ÀºÀºÀºÀºÀºÀºÀº,Àº%Àº.Àº6Àº7Àº=ÀºZÀº>ÀºFÀºGÀºlÀºcÀºnÀºvÀºwÀºÀºœÀº€ÀºˆÀº‰Àº²Àº¥Àº´Àº¼Àº½ÀºÕIÀ»3/// Return the total length of the current contour. À»#AÀ¼\!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. À¼i‚àÀ¿=‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. À¿NÀ¿a   À¿o‚,ÀÁ0£/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. ÀÁDÀÁL   ÀÁŸÀÂy€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀÂ…ÀÂ  ÀÂ“
ÀÂ›  ÀÂ ÀÂ¦  ÀÂ·ÀÃ$rÀÃ7   ÀÃ$ÀÃ% ÀÃš‰KÀÃ   ÀÃÒT ÀÃÒÀÃŞ ÀÃß	ÀÃå  ÀÃêÀÃğ   ÀÌ3€¯ÀÌÊ€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.ÀÌàÀÌá ÀÄ)PÀÄ.  ÀÄ;	ÀÄA  ÀÄFÀÄL   ÀÄ}€½ÀÄ„  ÀÄ‹ÀÄ   ÀÅ=@ÀÅD  ÀÅLÀÅQ   ÀÅåÀÅŠ  ÀÅÀÅ£  ÀÅ°ÀÅ¸   ÀÇiYÀÇu  ÀÇ€ÀÇ…  ÀÇ’ÀÇš   ÀÇÆ\ÀÇË  ÀÇ×ÀÇÜ  ÀÇéÀÇñ  ÀÇ÷
ÀÇÿ  ÀÈÀÈ
  ÀÈÀÉ%€‹ÀÉ*  ÀÉ7ÀÉ=  ÀÉEÀÉJ  ÀÉWÀÉ_  ÀÉe
ÀÉm  ÀÉrÀÉx  ÀÉ‰ÀÉ´€¿ÀÉ¹  ÀÉÂÀÉÇ   ÀÊv?ÀÊ{  ÀÊ…ÀÊŠ   ÀËh€‰ÀËm    ÀËô;ÀËù     ÀĞd†£ÀÑn/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. ÀÑ}ƒ>ÀÔWÀÔXÀÔ\‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.ÀÔbÀÔh  ÀÔsÀÔy  ÀÔ†ÀÔŒÀÔ›ÀÔ”ÀÔÀÔ—ÀÔ¤ÀÔªÀÔ¹ÀÔ²ÀÔ«ÀÔµÀÔ¿ÀÔÏ  ÀÔÙÀÔæ  ÀÕrÀÕƒ ÀÕÀÕœÀÕ­ ÀÕ¹ÀÖk<ÀÖ   ÀÖkÀÖlÀÕÓ€”ÀÕí  ÀÕğÀÕø  ÀÕÓÀÕÔÀÖ«ZÀÖ¾   ÀÖ«ÀÖ¬ À×	˜öÀØÔÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. ÀØû‚XÀÚÀÀÚÁÀÚÅ¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.ÀÚÆÀÚÍ  ÀÚÓÀÚŞ  ÀÚ÷ÀÚğÀÚùÀÛÀÛÀÛÀÛ0ÀÛ(ÀÛ2ÀÛFÀÛ@ÀÛHÀÛWˆ%ÀâöÀâ÷Àâı‡/// Construct a color filter that transforms a color by a 5x5 matrix, where
/// the fifth row is implicitly added in an identity configuration.
///
/// Every pixel's color value, repsented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
/// ```text
/// | R' |   | a00 a01 a02 a03 a04 |   | R |
/// | G' |   | a10 a11 a22 a33 a44 |   | G |
/// | B' | = | a20 a21 a22 a33 a44 | * | B |
/// | A' |   | a30 a31 a22 a33 a44 |   | A |
/// | 1  |   |  0   0   0   0   1  |   | 1 |
/// ```
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```ÀâşÀã  Àã"ÀãÀã$Àã=Àã2Àã?ÀãUÀãMÀãWÀãmÀãgÀãoÀã€€ôÀãíÀãîÀãÿW/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. ÀäÀä
ÀäÀä,Àä!Àä.ÀäDÀä<ÀäFÀäZÀäTÀä\ÀäxÀäòÀäóÀåd/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. ÀåÀåÀåÀå1Àå&Àå3ÀåIÀåAÀåKÀå_ÀåYÀåaÀå}ÀåŠ  Àå”Àå¥  Àå³ÀåÇ  ÀåÒÀåÜ  ÀæÀæ0 Àæ=ÀæT!Àæe ÀætÀæ˜,Àæ© ÀæÃÀæá,Àæò ÀçÀëŒzÀë    ÀëŒÀëÀì
ÁÀì!   Àì
ÀìÀçLVÀçe   ÀçLÀçMÀç¦‚¬Àç´    ÀêV2Àêp  ÀêsÀê{  ÀêVÀêWÀíÏ‚.Àíâ   ÀíÏÀíĞ Àğ†¥ÀñLD/// A [ColorFilter] that is backed by a native SkColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. Àñ~€ÏÀñŠÀñ‹Àñ ÀñÀñ–  Àñ¤ÀñªÀñºÀñ³Àñ«Àñ¶ÀñÃÀñÉÀññÀñØÀñÊÀñÑÀñÒÀñÛÀñæÀñçÀòQ€ËÀò]Àò^Àòd ÀòeÀòk  ÀòyÀòÀòÀòˆÀò€Àò‹Àò˜ÀòÀòÈÀò­ÀòŸÀò¦Àò§Àò°Àò»Àò¼Àó€ÆÀó+Àó,Àó= Àó>ÀóD  ÀóRÀóXÀóhÀóaÀóYÀódÀóqÀówÀó¬Àó†ÀóxÀóÀó€Àó‰Àó”Àó•Àóé€ÆÀóõÀóöÀô ÀôÀô  ÀôÀô"Àô2Àô+Àô#Àô.Àô;ÀôAÀôvÀôPÀôBÀôIÀôJÀôSÀô^Àô_Àô³€Àõ9o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  ÀõE5ÀõJ    Àõ}GÀõ‚  ÀõŒ	Àõ‘  Àõ—Àõœ   ÀõÇEÀõÌ  ÀõØÀõå   ÀöIÀö    Àö[IÀö`     Àö¨‹´ÀøŠÒ/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. Àøš[ÀøéÀøêÀøî9/// Creates an image filter that applies a Gaussian blur.ÀøñÀøù  ÀùÀù  Àù"Àù%  ÀùÀùÀù/Àù7Àù8Àùù`ÀúŸÀú Àú¦€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.Àú©Àú±  Àú¿ÀúÇ  ÀúºÀúĞÀû]aÀüÀüÀü€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.ÀüÀü  Àü%Àü-  Àü Àü6ÀüÂ‚_Àı·Àı¸Àı¾€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.Àı¿ÀıÌ  Àıë/Àıú  Àş	ÀşÀşÀÿ%ÍÀ 3À 4À ;€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).À >À T  À ZÀ p    À=ÀH    À”$À¡     À^ƒXÀd  À’H À’À¤ À§À¶  À»ÀÊ   ÀŞÀğ  Àø!À  À?@ÀW ÀfÀrÀsÀyÀ~ÀzÀÇLÀŞ   ÀÇÀÈÀcQÀw   ÀcÀdÀƒ@Àœ   ÀƒÀ„ÀMÀ*   ÀÀÀh€÷À‚  À…À  ÀhÀi À¸„kÀ¾  Àòa ÀòÀ
 ÀÀ  À#À2  À9ÀH   ÀWÀd  ÀnÀ{  À…À”  Àµ>ÀÍ ÀÜÀèÀéÀíÀòÀîÀ;€íÀF    À,SÀC   À,À-À	å<À	ù   À	åÀ	æÀ÷@À   À÷ÀøÀƒTÀ–   ÀƒÀ„ÀÛÀõ  ÀøÀ	   ÀÛÀÜ À
%‚óÀ
+  À
YE À
YÀ
k À
nÀ
}  À
…À
”   À
¢À
¯  À
ºÀ
Ç  À
Ó@À
ë À
úÀÀÀÀÀÀ[IÀr   À[À\ÀØ>Àì   ÀØÀÙÀ@À0   ÀÀÀ¨JÀ»   À¨À©Àö€ŞÀ  ÀÀ  ÀöÀ÷ À‚ìÀ   ÀMD ÀMÀ^ ÀaÀp  ÀxÀ‡   À•À¢  À­Àº  ÀÆ?ÀŞ ÀíÀùÀúÀÿÀÀ ÀMHÀd   ÀMÀNÀÇ=ÀÛ   ÀÇÀÈÀ	@À"   À	À
À™IÀ¬   À™ÀšÀæ€İÀ   ÀÀ  ÀæÀç Àƒ†À  À=N À=ÀP ÀSÀb  ÀnÀ}   ÀÀ¡  À°ÀÂ  ÀïBÀ ÀÀ"À#À+À0À,ÀysÀ   ÀyÀzÀFFÀZ   ÀFÀGÀ5@ÀN   À5À6Àğ_À   ÀğÀñÀS€ïÀm  ÀpÀx  ÀSÀT À–ÀÀ)/// An [ImageFilter] that is backed by a native SkImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. À++ÀsÀtÀx9/// Creates an image filter that applies a Gaussian blur.ÀyÀ“  	À À¦ÀµÀ®À§À±ÀÆÀ¾ÀÈÀ¶kÀUÀVÀ\€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À]Àq  	À~À„À“ÀŒÀ…ÀÀ¤ÀœÀ¦ÀykÀÀÀ!€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À"À5  	ÀBÀHÀWÀPÀIÀSÀhÀ`ÀjÀ:‚#À(À)À/€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.À0ÀD  	ÀQÀWÀfÀ_ÀXÀbÀwÀoÀyÀ½FÀûÀüÀ//// Converts a color filter to an image filter.ÀÀ  	À&À,À;À4À-À7ÀLÀDÀNÀ_ÃÀÀŸÀ§0/// Composes `_innerFilter` with `_outerFilter`.À¨À½  	ÀÊÀĞÀßÀØÀÑÀÛÀğÀèÀòÀ –€À!o/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  Àò5À÷    ÀYYÀ^  ÀhÀp  ÀwÀ  À†À‹   À$QÀ)  À5À=  ÀEÀM   ÀçOÀì  À÷Àÿ  ÀÀ   À`YÀe  ÀqÀ~  À†À‹   ÀUÀ  ÀÀ*   À %nÀ *  À 8À F  À RÀ `    À!(<À!©z/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. À!Õ€À"]À"^À"_a/// This class is created by the engine, and should not be instantiated
/// or extended directly. À";À"<À"BÀ"SÀ"C    À9/£áÀ:v@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// À:ÉˆÀ?äÀ?åÀ?ë„æ/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À?ñÀ?ù  À@	À@
  À@À@  À@+À@:  À@I"À@S  À@qÀ@  -À@]À@eÀ@fÀ@À@”À@©À@•À@£À@¨À@¤À@³À@¹À@ÌÀ@ºÀ@ÈÀ@ËÀ@ÉÀ@ÖÀ@ÜÀ@ëÀ@äÀ@İÀ@çÀ@õÀ@ûÀAÀAÀ@üÀAÀAÀAÀAHÀA-ÀA%ÀAÀA(ÀA0ÀA?ÀAGÀA@ÀARÀAWÀAXÀAYÀAZÀCŒ
ÀJƒÀJ„ÀJŠ†½/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].ÀJÀJ˜  ÀJ£ÀJ«  ÀJ¶ÀJÃ  ÀJĞÀJß  ÀJî"ÀJø  ÀKÀK$  ÀK0ÀK9  ÀKCÀKK  'ÀKÀK
ÀKÀKXÀKcÀKiÀK€ÀKjÀKxÀKÀKyÀKŠÀKÀKŸÀK˜ÀK‘ÀK›ÀK©ÀK¯ÀKÀÀK¹ÀK°ÀK¼ÀKÊÀKĞÀKüÀKáÀKÙÀKÑÀKÜÀKäÀKóÀKûÀKôÀLÀLÀLÀLÀLÀQ&‰ŸÀWrÀWsÀWx†/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.ÀW~ÀW†  ÀW‘ÀW  ÀW«ÀWº  ÀWÉ"ÀWÓ  ÀWñÀWù  ÀXÀX  ÀX1ÀX?  >ÀWİÀWåÀWæÀXÀX(ÀX ÀX$ÀX%ÀX*ÀXNÀXTÀXkÀXUÀXcÀXjÀXdÀXuÀX{ÀXŠÀXƒÀX|ÀX†ÀX”ÀXšÀX«ÀX¤ÀX›ÀX§ÀXµÀX»ÀXÎÀXÇÀX¼ÀXÊÀXØÀXŞÀXïÀXèÀXßÀXëÀXùÀXÿÀYÀYÀY ÀYÀYÀY%ÀYQÀY6ÀY.ÀY&ÀY1ÀY9ÀYHÀYPÀYIÀY[ÀY`ÀYaÀYbÀYc  À:“2À:˜    ÀBé€”ÀBî  ÀBúÀC  ÀCÀC  ÀC#ÀC1  ÀC<ÀCA  ÀCJÀCX   ÀO€¬ÀO“  ÀOŸÀO§  ÀO¯ÀO·  ÀO¿ÀOÇ  ÀOÎÀOÙ  ÀOàÀOî  ÀOùÀOş  ÀPÀP   ÀP=€åÀPB  
ÀPOÀPW  ÀP^ÀPf  ÀPmÀPu  ÀPÀP‰  ÀPÀP–  ÀP›ÀP£  ÀP­ÀP¸  ÀP¿ÀPÍ  ÀPØÀPİ  ÀPæÀPô   ÀZÈ€¾ÀZÍ  ÀZØÀZà  ÀZèÀZğ  ÀZøÀ[  À[
À[  À[#À[(  À[1À[9  À[DÀ[L  À[UÀ[c   À[Š„À[–  À[ªÀ[·  À[¾À[Í    À]…ƒÀ]V=/// A shader (as used by [Paint.shader]) that tiles an image. À]u„\ À_˜À_£ø/// Creates an image-tiling shader. The first argument specifies the image to
/// tile. The second and third arguments specify the [TileMode] for the x
/// direction and y direction respectively. The fourth argument gives the
/// matrix to apply to the effect. All the arguments are required and must not
/// be null, except for [filterQuality]. If [filterQuality] is not specified
/// at construction time it will be deduced from the environment where it is used,
/// such as from [Paint.filterQuality].À_¤À_«  À_±À_»  À_¿À_É  À_ÍÀ_Ú  À_èÀ_ø  "À_|À_}À_ƒÀ_”À_„À`À`À`%À`À`À`!À`SÀ`YÀ`eÀ`^À`ZÀ`aÀ`lÀ`rÀ`~À`wÀ`sÀ`zÀ`…À`‹À`›À`”À`ŒÀ`—À`¢À`§À`¨À`©À`ª  ÀaÔ5ÀaÙ    Àb€‡Àb  Àb#Àb+  Àb1Àb6  Àb:Àb?  ÀbCÀbH  Àb[Àbh    Àb—’ÆÀdn/// An instance of [FragmentProgram] creates [Shader] objects (as used by [Paint.shader]) that run SPIR-V code.
///
/// This API is in beta and does not yet work on web.
/// See https://github.com/flutter/flutter/projects/207 for roadmap.
///
/// [A current specification of valid SPIR-V is here.](https://github.com/flutter/engine/blob/main/lib/spirv/README.md)
/// Àg¢rÀgÍÀgÎÀgÏ ÀgÖÀgë  ÀgõÀgû  Àg¢Àg£Àg©ÀgºÀgªÀhÀi!Ài'  Ài=ÀiL   ÀdBƒ\Àf9Ç/// Creates a fragment program from SPIR-V byte data as an input.
///
/// One instance should be created per SPIR-V input. The constructed object
/// should then be reused via the [shader] method to create [Shader] objects
/// that can be used by [Shader.paint].
///
/// [A current specification of valid SPIR-V is here.](https://github.com/flutter/engine/blob/master/lib/spirv/README.md)
/// SPIR-V not meeting this specification will throw an exception. ÀfGÀf\  ÀffÀfl  ÀfxÀi^9Àic    ÀišGÀiŸ  Ài¥Ài­  Ài²Ài¸   ÀiåŠŞÀq+†Ü/// Constructs a [Shader] object suitable for use by [Paint.shader] with
/// the given uniforms.
///
/// This method is suitable to be called synchronously within a widget's
/// `build` method or from [CustomPainter.paint].
///
/// `floatUniforms` can be passed optionally to initialize the shader's
/// uniforms. If they are not set they will each default to 0.
///
/// When initializing `floatUniforms`, the length of float uniforms must match
/// the total number of floats defined as uniforms in the shader, or an
/// [ArgumentError] will be thrown. Details are below.
///
/// Consider the following snippit of GLSL code.
///
/// ```
/// layout (location = 0) uniform float a;
/// layout (location = 1) uniform vec2 b;
/// layout (location = 2) uniform vec3 c;
/// layout (location = 3) uniform mat2x2 d;
/// ```
///
/// When compiled to SPIR-V and provided to the constructor, `floatUniforms`
/// must have a length of 10. One per float-component of each uniform.
///
/// `program.shader(floatUniforms: Float32List.fromList([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));`
///
/// The uniforms will be set as follows:
///
/// a: 1
/// b: [2, 3]
/// c: [4, 5, 6]
/// d: [7, 8, 9, 10] // 2x2 matrix in column-major order
///
/// `imageSamplers` must also be sized correctly, matching the number of UniformConstant
/// variables of type SampledImage specified in the SPIR-V code.
///
/// Consider the following snippit of GLSL code.
///
/// ```
/// layout (location = 0) uniform sampler2D a;
/// layout (location = 1) uniform sampler2D b;
/// ```
///
/// After being compiled to SPIR-V  `imageSamplers` must have a length
/// of 2.
///
/// Once a [Shader] is built, uniform values cannot be changed. Instead,
/// [shader] must be called again with new uniform values. Àq8ÀqF  ÀqX"Àql   ÀtÇ€”ÀtÌ  ÀtÙÀtê  ÀtõÀu  Àu!Àu'    Àu_ƒÈÀu  Àu¢ ÀvKÀvZ€ /// This class is created by the engine and should not be instantiated
/// or extended directly.
///
/// To create a [_FragmentShader], use a [FragmentProgram].Àv`Àvf  ÀvsÀvy  ÀvŒÀv’  Àv©Àv®Àv¯Àv°Àv±Àv·ÀvÍ  ÀvÙ Àvë  Àvı(Àw  Àx­xÀxÁ   Àx­Àx®Àw*ÀwD  ÀwGÀwO  Àw*Àw+Àu_Àu`ÀufÀuwÀugÀ{"‘ÛÀ{`7/// A set of vertex data used by [Canvas.drawVertices]. À{ˆ À~‘À~™‚â/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The [mode] and [positions] parameters must not be null.
/// The [positions] parameter is a list of triangular mesh vertices(xy).
///
/// If the [textureCoordinates] or [colors] parameters are provided, they must
/// be the same length as [positions].
///
/// The [textureCoordinates] parameter is used to cutout
/// the image set in the image shader.
/// The cut part is applied to the triangular mesh.
/// Note that the [textureCoordinates] are the coordinates on the image.
///
/// If the [indices] parameter is provided, all values in the list must be
/// valid index values for [positions].
/// e.g. The [indices] parameter for a simple triangle is [0,1,2].À~ŸÀ~«  À~´À~Â  À~Ò À~á  À~øÀ  ÀÀ  À,À2À?À8À3À;ÀIÀOÀaÀZÀPÀ]ÀƒŸˆuÀˆÈÀˆÉÀˆÌ„ê/// Creates a set of vertex data for use with [Canvas.drawVertices], directly
/// using the encoding methods of [new Vertices].
/// Note that this constructor uses raw typed data lists,
/// so it runs faster than the [Vertices()] constructor
/// because it doesn't require any conversion from Dart lists.
///
/// The [mode] parameter must not be null.
///
/// The [positions] parameter is a list of triangular mesh vertices and
/// is interpreted as a list of repeated pairs of x,y coordinates.
/// It must not be null.
///
/// The [textureCoordinates] list is interpreted as a list of repeated pairs
/// of x,y coordinates, and must be the same length of [positions] if it
/// is not null.
/// The [textureCoordinates] parameter is used to cutout
/// the image set in the image shader.
/// The cut part is applied to the triangular mesh.
/// Note that the [textureCoordinates] are the coordinates on the image.
///
/// The [colors] list is interpreted as a list of ARGB encoded colors, similar
/// to [Color.value]. It must be half length of [positions] if it is not
/// null.
///
/// If the [indices] list is provided, all values in the list must be
/// valid index values for [positions].
/// e.g. The [indices] parameter for a simple triangle is [0,1,2].ÀˆÒÀˆŞ  ÀˆçÀˆô  À‰À‰  À‰)À‰5  À‰@À‰M  À‰\À‰bÀ‰oÀ‰hÀ‰cÀ‰kÀ‰yÀ‰À‰‘À‰ŠÀ‰€À‰  ÀŒ€ãÀŒ  ÀŒ#ÀŒ-  ÀŒFÀŒK  ÀŒ]ÀŒj  ÀŒÀŒ  ÀŒ¯ÀŒ»  ÀŒÏÀŒÜ    À’)À ÄÌÀ•™ƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. À•Å„( À˜kÀ˜q‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.À˜rÀ˜ƒ  À˜À˜•  À˜OÀ˜PÀ˜VÀ˜gÀ˜WÀ˜¢À˜¨À˜¹À˜²À˜©À˜µÀ›ÁÀ›Ò   AÀ™ğ€ÎÀ™õ  ÀšÀš  Àš0Àš8  ÀšQ
ÀšY  ÀšqÀšy  Àš“Àš›   À›à=À/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   À!•½À±–“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. À± À±§  À±®À±µ   À²á{À²æ  À²şÀ³  À³À³%   À³_€ëÀ³d  À³oÀ³w  À³
À³–  À³¬À³´  À³ÌÀ³Ô  À³íÀ³ı  À´À´&   À´NcÀµ-/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   Àµµ_À¶è"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À·€ßÀ·½€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À·Ç	À·Ï  À·Ò	À·Ú   À·ûDÀ¹€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À¹	À¹  À¹
À¹#   À¹C8À¹H  À¹O	À¹W  À¹Z	À¹b   À¹€ˆÀ¹ÙR/// Add a rotation to the current transform. The argument is in radians clockwise. À¹àÀ¹è   ÀºJÀ»%/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À»*	À»2  À»5	À»=   À»YFÀ»é€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À»óÀ¼    À¼¢?À¼§  À¼²À¼¿   À¼å‚iÀ¾Ù×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   À¿QEÀ¿V  À¿dÀ¿q   À¿š‚îÀÁ{Å/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. ÀÁ„	ÀÁŠ  ÀÁ‘ ÀÁ™  ÀÁ³ÀÁ¹  ÀÁ¡ÀÁ§ÀÁ¨ÀÁÆÀÂ‹€ÑÀÂ  ÀÂšÀÂ¢  ÀÂ¸
ÀÂÀ  ÀÂÕÀÂİ  ÀÂôÀÂü  ÀÃ
ÀÃ  ÀÃ1ÀÃ7   ÀÃ`‚XÀÅ–/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. ÀÅÀÅ  ÀÅ$ÀÅ*  ÀÅ7ÀÅ»OÀÅÀ  ÀÅËÀÅØ  ÀÅŞÀÅä   ÀÆ‚1ÀÇˆd/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. ÀÇ‘	ÀÇ—  ÀÇÀÇ£  ÀÇ°ÀÈBEÀÈG  ÀÈQ	ÀÈW  ÀÈ\ÀÈb   ÀÈ‹‹3ÀÓŠ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are curretnly
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
///    clipPath(Path()
///      ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///      ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///    clipPath(Path()
///      ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///      ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   ÀÓÁPÀÓÆ  ÀÓÚÀÓç   ÀÔ„@À×™ƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   ÀØX\ÀØ]  ÀØwÀØ„   ÀØ¸JÀÙi€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. ÀÙsÀÙz  ÀÙ€ÀÙ‹   ÀÚDÀÚ
  ÀÚ	ÀÚ  ÀÚ ÀÚ%   ÀÚMÄÀÛ=€â/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin. ÀÛF	ÀÛN  ÀÛQ	ÀÛY  ÀÛ\ÀÛc   ÀÜ€ÚÀÜ  ÀÜ#	ÀÜ+  ÀÜ?	ÀÜG  ÀÜ[	ÀÜc  ÀÜw	ÀÜ  ÀÜ“ÀÜ£  ÀÜÁÀÜË   ÀÜò€şÀİŒ€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. Àİ–Àİ   Àİó[Àİø  ÀŞÀŞ  ÀŞ ÀŞ*   ÀŞRYÀŞâ€†/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style]. ÀŞë	ÀŞñ  ÀŞöÀŞı   Àß®€äÀß³  Àß½ÀßÅ  ÀßÛ
Àßã  ÀßøÀà   ÀàÀà  Àà7ÀàG  ÀàeÀào   Àà–@Àá.€/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style]. Àá8Àá?  ÀáEÀáL   ÀáÙ€’ÀáŞ  ÀáéÀáö  ÀâÀâ  Àâ=ÀâG   Àâo‚Àã…/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. ÀãÀã—  ÀãÀã¤  ÀãªÀã±   Àäv€¼Àä{  Àä‡Àä”  Àä­Àäº  ÀäÓÀäã  ÀåÀå   Àå6Àåü€º/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style]. Àæ	Àæ  ÀæÀæ   ÀæÈ€äÀæÍ  Àæ×Àæß  Àæõ
Àæı  ÀçÀç  Àç1Àç9  ÀçQÀça  ÀçÀç‰   Àç°ÆÀèÄ/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style]. ÀèÏÀè×  ÀèÙÀèá  ÀèèÀèï   Àéy€ÌÀé~  ÀéŠÀé’  Àé§Àé¯  ÀéÄÀéÌ  ÀéæÀéö  ÀêÀê    ÀêIƒ¼Àìæ‚/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. Àìî	Àìô  ÀìùÀí  ÀíÀí  ÀíÀí%  Àí/Àí6   ÀîCÀî  	ÀîÀî  Àî3
Àî;  ÀîOÀîW  ÀîmÀîu  ÀîŒÀî”  Àî¯Àî·  ÀîÒÀîØ  ÀîòÀï  ÀïÀï)   ÀïO±ÀğM€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀğV	Àğ\  ÀğaÀğh   Àñ€†Àñ  Àñ	Àñ  Àñ.Àñ>  Àñ\Àñf   Àñ‚RÀò7€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀòAÀòH  ÀòNÀòV  Àò]Àòd   ÀóâÀóê  ÀóõÀóı  ÀôÀô   Àô7Àô?  ÀôVÀôf  ÀôˆÀô’  Àô±Àô¶   Àôç…ŒÀö£¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. Àö±Àö¸  Àö¾ÀöÄ  ÀöÈÀöÎ  ÀöÒÀöÙ   Àúv‚#Àú~  ÀúÀú•  Àú´Àú¼  ÀúİÀúå  ÀûÀû  Àû/Àû7  ÀûZÀûb  ÀûƒÀû‹  Àû«Àû³  ÀûÕÀûİ  Àü Àü  Àü6Àü@  ÀücÀüh   Àü†ôÀÿ¯‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. Àÿ½ÀÿÄ  ÀÿÊÀÿĞ  Àÿ×Àÿİ  ÀÿáÀÿè   À”‚/Àœ  À«À³  ÀÒÀÚ  ÀşÀ  À)À1  ÀVÀ^  À„ÀŒ  À­Àµ  ÀÕÀİ  ÀÿÀ  À*À:  À`Àj  ÀÀ’   ÀÇ€èÀ,[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. À8ÀA   À²?À·  ÀÄÀÍ   Àõ„èÀƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [new ParagraphBuilder] constructor. For more details see
/// [TextAlign] and the discussion at [new ParagraphStyle].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. ÀÀ%  À/À7   Àá‚Àı/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. ÀÀ  ÀÀ+  À2À9   À÷‚ÆÀl]/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. ÀzÀ…  ÀÀœ  À£Àª   ÀÁ€¹ÀÆ  ÀÒÀâ  ÀÀ  À)À.  ÀKÀX   À~…ÀwƒË/// Draws the set of [Vertices] onto the canvas.
///
/// The [blendMode] parameter is used to control how the colors in
/// the [vertices] are combined with the colors in the [paint].
/// If there are no colors specified in [vertices] then the [blendMode] has
/// no effect. If there are colors in the [vertices],
/// then the color taken from the [Shader] or [Color] in the [paint] is
/// blended with the colors specified in the [vertices] using
/// the [blendMode] parameter.
/// For purposes of this blending,
/// the colors from the [paint] are considered the source and the colors from
/// the [vertices] are considered the destination.
///
/// All parameters must not be null.
///
/// See also:
///   * [new Vertices], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. À„À  À—À¢  À¬À³   À€ÂÀ”  À¢À¬  ÀÊÀÏ  ÀîÀş  À À*   ÀU8À,“½/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.centerX,
///           translateY: sprite.centerY,
///         ),
///     ], <Rect>[
///       for (Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.centerX,
///           translateY: sprite.centerY,
///         ),
///     ], <Rect>[
///       for (Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. À, À,'  À,>À,Q  À,mÀ,y  À,À,  À,¶À,Â  À,İÀ,ä  À,şÀ-   À4‘ÀM—ß/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       final double rectX = sprite.spriteIndex * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.centerX - 5.0;
///       transformList[i * 4 + 3] = sprite.centerY - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   int index;
///   double centerX;
///   double centerY;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       final double rectX = sprite.spriteIndex * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.centerX,
///         translateY: sprite.centerY,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. ÀMÀM¤  ÀM¾ÀMË  ÀMíÀMú  ÀNÀN   ÀN;ÀNG  ÀNeÀNl  ÀN‰ÀN   ÀR­“ÀRµ  	ÀRÀÀRĞ  ÀRòÀRü  ÀSÀS   ÀSHÀSP  ÀSkÀSx  ÀS›ÀS¨  ÀSÃÀSÏ  ÀSëÀSğ  ÀTÀT   ÀTD‚ÀU-€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. ÀU8	ÀU>  ÀUCÀUJ  ÀUPÀUX  ÀUbÀUh   ÀVL€§ÀVQ  ÀV]	ÀVc  ÀV{	ÀV€  ÀV™ÀV¡  ÀV¾ÀVÄ    ÀV÷‰€ÀXfN/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method. ÀX“€ÊÀYXÀYYÀYZ€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder]. ÀY5ÀY6ÀY<ÀYMÀY=À]¬À]± À]½À]Æ™À^€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À_cÀ`=€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   ÀYa‚ÀÀZ†/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. ÀZ	ÀZ“  ÀZ™
ÀZ   À\$^À\,  À\5	À\:  À\@
À\E  À\LÀ\`   À\†€ôÀ\şn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À]~)À]ƒ    ÀXFÀXGÀXMÀX^ÀXNÀ`y†fÀaT€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. Àa‰€å ÀbIÀbX€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor. Àb-Àb.Àb4ÀbEÀb5ÀfÍÀfÕ  Àb®¬Àd;u/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   Àbq9Àbv    Àd^‚Àe{
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.   Àf|MÀf  ÀfÀf˜    Àfáœ—Àg<T/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. ÀgG‚Ì ÀhÒÀhØp/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.Àhß(Àhå  ÀiÀi  Ài,Ài2  !ÀhìÀhòÀh÷ÀiÀhøÀiÀi!Ài"Ài>ÀiJÀiPÀi^Ài}ÀiWÀiQÀiZÀi`Ài‡ÀiÀiœÀi¼Ài•ÀiÀi˜ÀiÀiÆÀiÌÀiŞÀjÀiØÀiÍÀiÛÀià	Àj,Àj( Àj9Àjk&Àj| ÀjÀj•'Àj¦ Àj¸Àj¶Àj»ÀjÀ#ÀjÑ ÀjßÀjİÀjâÀjç#Àjø ÀkÀkÀk	Àk&Àk Àk0Àk.Àk3Àk9€¼Àkğ€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. Àkú4Àm(/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. Àm3iÀm’O/// The standard deviation of the Gaussian to convolve with the shadow's shape. Ào!€®Ào¡n/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   À}@GÀ}T   À}@À}AÀm¡|ÀnÀh/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// ÀnÕÀnİ   ÀoÓ‚‹Àqãõ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   Àrb€õÀrÉ[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. ÀrÏÀr×   Às[…ğÀwgƒÖ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from a
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} Àwl	Àwu  Àww	Àw€  Àw‚ÀwŠ   ÀyO‚şÀz€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} ÀzÀz,  Àz.Àz=  Àz?ÀzG   À|Q€ëÀ|k  À|nÀ|v  À|QÀ|RÀ~E„áÀ~U  À~dÀ~s   Àƒ*LÀƒ=   Àƒ*Àƒ+ ÀƒzŠ–À„0€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. À„e À„tÀ„uÀ„v À„wÀ„}   À‰ëÀ‰ï  À‰ûÀŠ  ÀŠÀ‰šNÀ‰Ö1/// The length, in bytes, of the underlying data.   ÀŠÀŠ¤y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   À„‰`À…^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. À…À…$   À…í‚æÀ†…r/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. À†À†—   Àˆ×SÀˆÜ  ÀˆâÀˆí  ÀˆòÀ‰   À‰.hÀ‰6  À‰EÀ‰M  À‰VÀ‰f   À‹6‚£ÀQ‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   Àİ1Àâ     ÀáÀÎ€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. ÀÀÀÀ   ÀãƒœÀ“À“À“Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À“À“-  À“:À“H  À“RÀ“`  À“kÀ“q  À“~ À“”   À•"À•'  À•úÀ•ÿ  À–ÙÀ–Ş  À•c€“À•Öd/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À–>€—À–²e/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À—2€¯À—©h/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   	ÀUÀ…H/// Creates an image descriptor from encoded data in a supported format. ÀÀ   ÀslÀ{  ÀˆÀ™  À À±   À”‚€œÀ”‡  À”À”¡  À”¯À”À  À”Ç	À”Ì  À”Ò
À”×  À”ŞÀ”ã  À”ìÀ”ñ   À•1/À•5    À–
1À–    À–ğ?À–ô    À—å€£À˜]n/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   À˜Œ„îÀš/‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. ÀšAÀšG  ÀšSÀšY   À}tÀ‚  À”À›  À¤À©  ÀµÀº    À¥0ƒ×À¦ŠS/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. À¦ÁBÀ¦äÀ¦åÀ¦æ À¦çÀ¦í  À¦ö
À¦ü   À§IÀ§I2/// A string containing details about the failure. À§UiÀ§¹O/// If available, the stack trace at the time [Picture.toImageSync] was called.  À§ÃBÀ§Ö   À§ÃÀ§Ä  ³éÀ Nc¿‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ¿»€îÀ @¤€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) À @®HÀ Aó4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) À AûMÀ CE9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À CMìÀ E2Ğ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À E>­À Fä‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À Fğ‚šÀ I…‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À I‚„À L‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À L‚˜À Nª‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À Nµ‚À Q=‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À QH‚gÀ S¨‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À S´‚]À V
‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À V;À WN+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À WVÀÀ Y©/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À YƒVÀ \iƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À \¿…!À aÚ„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À aşƒŞÀ eÕƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À eá7À g"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À g:À hP$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À h\{À iÍb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À iÜ‘À kdy/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À krƒâÀ oKƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À oYsÀ pÃU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À pÑÅÀ rŒ¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À r›ÔÀ tf²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À tt‚ÙÀ wE‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À wo‚÷À zc‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À zk‚dÀ |Å‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À |Ô‚ãÀ ²‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À ¼‚À ‚?‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À ‚NŒ{À ‡È…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À ˆY€ÙÀ ‰.€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ‰7€²À ‰æ€¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ‰î‚À Œv‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Œ‚EÀ Â‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À Ë†ÇÀ ¿€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À Í…À ‘Nr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À ‘WËÀ “µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À “'‚hÀ •‰‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À •”ˆÀ —?g/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À —N‚YÀ ™¢‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À ™¬ÌÀ ›s®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ›}‚À ÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À ™‚ßÀ 2T/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À ¤€·À ŸW€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À Ÿ`À  o/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À  {Œ‡À  ¯./// Different ways to clip a widget's content.  À  ¸‚8À ¢ì‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¢õ‚_À ¥L‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À ¥Yƒ.À ¨~ƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¨Œ„sÀ ¬é„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À óf†;À ôòY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À õ€‚À õt/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À õ€À öx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À ö €»À öÎ€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À öà‚¾À ù›‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À ù£ÔÀ ùç>/// The format of pixel data given to [decodeImageFromPixels].  À ù÷€¼À ú«€­/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. À ú¸€¼À ûl€­/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha.    ÀQƒ•ÀQ´€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  ÀQÅ¯ÀSm—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> ÀSy0ÀT¢/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    ÀT®ˆLÀUb€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  ÀUt£ÀW„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. ÀW‡ÀX™k/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation ÀX¦$ÀYÅ/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. ÀYÎ‚À[Mn/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation À[T£À\æ}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    ÀÌçƒ{ÀÍ]4/// Styles to use for blurs in [MaskFilter] objects.  ÀÍ¤€–ÀÎ4€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. ÀÎ?€ÍÀÏ€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. ÀÏ€æÀÏò€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. ÀÏücÀĞZY/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    À"f“À)9†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  À)F‚£À+ä‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) À+îƒ5À/ƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) À/(ƒ|À2ƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) À2©‚½À5a‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    Ày)÷Àyíw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀyüQÀzDE/// Draw each sequence of three points as the vertices of a triangle. ÀzR[Àz K/// Draw each sliding window of three points as the vertices of a triangle. Àz²kÀ{]/// Draw the first point and each sliding window of two points as the vertices of a triangle.    ÀŒÿ„À»r/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints].  ÀÉ·Àz/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). À…€éÀi€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). Às€šÀ‘€Š/// Draw the entire sequence of point as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À‘À‘x/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  À‘›BÀ‘Ó5/// Subtract the new region from the existing region. À‘âBÀ’6/// Intersect the new region from the existing region.      ƒå‚…Vj/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate} …c	…i   …õ€©…ú  ††   † €Æ†¥  †´†¼   ‡h‡m  ‡}‡Š   ˆ~€Äˆƒ  ˆ’ˆš   ‰Dm‰J  ‰V‰]  ‰_‰g   À2Ü‡²À9'†</// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. À9@À9K  À9TÀ9Z  À9hÀ9n  À9}À9ƒ  À9“À:ˆ¢À@İ†>/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀA ÀA  ÀAÀA"  ÀA0ÀA6  ÀAEÀAK  ÀA[ÀC4©ÀDj0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. ÀD~ÀD‰  ÀDÀD¤   ÀDßÀDì  ÀEÀE  ÀE=ÀES   ÀE÷‹ÀKš…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	ÀK³ÀK¾  ÀKÇ	ÀKÌ  ÀKÔ
ÀKÙ  ÀKâÀKï  ÀKøÀL  ÀLÀL!  ÀL,ÀL2  ÀL@ÀLF  ÀLUÀL[  ÀLkÀ5k€åÀ5u  À5†À5“   À6RµÀ6^  À6oÀ6}   À8	$À8  À8&À8.  À85À8=   ÀŸ2…üÀ¢ˆ‚b/// Converts a method that receives a value-returning callback to a method that
/// returns a Future.
///
/// Return a [String] to cause an [Exception] to be synchronously thrown with
/// that string as a message.
///
/// If the callback is called with null, the future completes with an error.
///
/// Example usage:
///
/// ```dart
/// typedef IntCallback = void Function(int result);
///
/// String _doSomethingAndCallback(IntCallback callback) {
///   Timer(Duration(seconds: 1), () { callback(1); });
/// }
///
/// Future<int> doSomething() {
///   return _futurize(_doSomethingAndCallback);
/// }
/// ```À¢’À¢’À¢•À¢¥    À "mÀ \1/// Callback signature for [decodeImageFromList].  À À ˆ   ÀõdÀ24/// Generic callback signature, used by [_futurize].À<À< ÀOÀR   À[€ÕÀö€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.ÀŸÀŸ ÀŸÀŸ'       — <€†€¤€¥€¦€¶€Ç€È_¯‚ ‚P‚‚ïƒ-ƒ0ƒ~ƒ¤ƒ¥ƒå„
„[„¡„í…=…P…Q…p…£…ã…ò…ô…õ††L†††Ÿ† †Å†ü‡V‡e‡g‡h‡”‡Íˆˆlˆ{ˆ}ˆ~ˆ£ˆÚ‰2‰A‰C‰D‰p‰°‰²‰³‰ç‰ëŠ;Š‹ŠÚ‹‹‹6‹:‹F‹m‹©‹àŒŒŒ#ŒtŒÃ?COœäìğşU›©åëDj‘¶¼ZˆÔ‘!‘F‘b‘™‘š‘Ú‘à’-’=’b’‰’¯’µ’ø’ş“I“V“‹“­“Ï“ñ”” ”u”{” ”Ç”í•:•j•p•³•¹––?–u–«–á—#—$—R—X—€—†—®—Ô—û˜ ˜3˜4˜m˜s˜Â˜ä™™™G™M™™À™æ™çššKšLš…š³š´šì›››c›™›Ÿ›×›òœ"œ&œ'œpœ¸œ¾œöJ{€Ğı;T†Š‹ÔŸ
ŸŸHŸcŸ“Ÿ—Ÿ˜Ÿé   T n Ÿ £ ¤ â¡¡=¡]¡¡¢¡£¡î¡ô¢H¢f¢l¢ª¢È££C£€£¼£í£ñ£ò¤!¤'¤o¤²¤¸¥¥O¥¥Ô¥Ú¦'¦q¦¼§§V§¦§ó¨D¨q¨w¨Æ¨æ©©2©G©^©s©‚©ª©²©¿©Ö©øªª&ªjªªªî«0«;«C«I«M«N«‘«×«İ¬)¬p¬»­
­U­•­½­ü®®®B®h®Ÿ®¼®Ê¯¯Z¯¢¯«¯È¯ú°(°H°e°w°Â±±^±g±m±q±r±¿±Å±ğ²#²@²t²x²y²…²¨²È²Û³³³3³T³X³Y³e³‹³Œ³˜³æ³è³é´´ ´m´·´Ö´Úµ+µxµÇ¶¶e¶°¶ô¶ø·H·“·ä¸0¸~¸Ë¹¹]¹¬¹òººº_º¬ºö»H»•»æ¼'¼+¼R¼V¼¤¼å½6½ƒ½Ô¾#¾r¾¾‘¾Ÿ¾£¾î¾ÿ¿¿_¿r¿¸¿¹¿ıÀ @À @?À @EÀ @¢À @«À @¬À @ëÀ @ñÀ A@À AOÀ AUÀ AÀ A–À AñÀ AøÀ AùÀ B8À B>À B‰À BšÀ B À BâÀ BèÀ CCÀ CJÀ CKÀ CˆÀ CÀ CÜÀ D-À DJÀ DPÀ DÀ DËÀ DÑÀ E0À E;À E<À EzÀ E€À E©À E¯À EıÀ FÀ FbÀ FhÀ F·À FâÀ FíÀ FîÀ G6À GƒÀ GĞÀ GŞÀ GäÀ H#À H)À HvÀ H¾À HÎÀ HÔÀ I À I&À IƒÀ IŒÀ IÀ IÚÀ J(À JrÀ JxÀ J²À J¸À KÀ KWÀ K]À K©À K¯À LÀ LÀ LÀ LeÀ L¸À MÀ MÀ MMÀ MSÀ M À MñÀ M÷À NDÀ NJÀ N¨À N²À N³À OÀ OUÀ OŸÀ O¥À OàÀ OæÀ P8À P„À PŠÀ P×À PİÀ Q;À QEÀ QFÀ Q•À QµÀ Q»À R	À RÀ R_À R«À RßÀ RåÀ S0À SAÀ SGÀ S¦À S±À S²À TÀ TÀ T"À TpÀ TvÀ TÆÀ UÀ UAÀ UGÀ U’À U£À U©À VÀ VÀ VÀ VdÀ V˜À VÀ VëÀ VñÀ WLÀ WSÀ WTÀ W“À W™À WèÀ X4À XZÀ X`À X®À X´À YÀ YÀ YÀ YcÀ YiÀ Y¸À ZÀ ZÀ Z^À Z‡À ZÀ ZŞÀ ZäÀ [DÀ [JÀ [ZÀ [`À [¢À [êÀ \À \PÀ \gÀ \sÀ \tÀ \¼À \½À ]À ].À ]4À ]€À ]ÍÀ ]üÀ ^À ^SÀ ^ŸÀ ^ÅÀ ^ËÀ _À _jÀ _»À _ÁÀ `À `2À `8À `–À `œÀ `¬À `²À aÀ aÀ a[À awÀ aÁÀ aØÀ aûÀ aüÀ bEÀ btÀ bzÀ bËÀ cÀ cjÀ c‰À cÀ cÛÀ d(À dWÀ d]À d¼À dÂÀ dÒÀ dØÀ eÀ eXÀ e¨À eÓÀ eŞÀ eßÀ f-À fLÀ fRÀ f›À f¬À f²À gÀ gÀ gÀ gjÀ g‰À gÀ gØÀ géÀ gïÀ hNÀ hYÀ hZÀ h•À h›À hçÀ i4À icÀ iiÀ iËÀ iÙÀ iÚÀ j-À j3À jÀ jÌÀ jûÀ kÀ kbÀ koÀ kpÀ k¹À kãÀ kéÀ l9À l‚À lĞÀ lıÀ mÀ mOÀ mœÀ mËÀ mÑÀ n2À n8À nHÀ nNÀ n‡À nÎÀ oÀ oIÀ oVÀ oWÀ o¥À o½À oÃÀ pÀ pÀ plÀ prÀ p‚À pˆÀ pÁÀ pÎÀ pÏÀ qÀ qÀ qmÀ q„À qŠÀ qÓÀ qäÀ qêÀ r"À r(À rŠÀ r˜À r™À råÀ róÀ rùÀ sHÀ s_À seÀ s®À s¿À sÅÀ sıÀ tÀ tdÀ tqÀ trÀ tÀÀ tÙÀ tßÀ u.À u}À uƒÀ uÏÀ vÀ vdÀ vjÀ v¹À vİÀ vãÀ wCÀ wlÀ wmÀ w¾À w×À wİÀ x&À x,À xuÀ xÅÀ xëÀ xñÀ yLÀ yRÀ ybÀ yhÀ y¸À yáÀ z0À zaÀ zhÀ ziÀ zºÀ zÓÀ zÙÀ {"À {rÀ {ŸÀ {¥À | À |À |À |À |^À |­À |ÃÀ |ÑÀ |ÒÀ }#À }<À }BÀ }‹À }‘À }ÚÀ ~*À ~_À ~eÀ ~ÂÀ ~ÈÀ ~ØÀ ~ŞÀ À bÀ °À ¹À ºÀ €À €$À €*À €sÀ €ÃÀ €ğÀ €öÀ XÀ ^À nÀ tÀ ÃÀ ÙÀ ‚$À ‚=À ‚KÀ ‚MÀ ‚NÀ ‚¦À ‚áÀ ‚åÀ ƒBÀ ƒ‰À ƒÀ ƒâÀ „6À „ŒÀ „àÀ „äÀ …2À …mÀ …qÀ …ÊÀ …ÎÀ †À †cÀ †‚À ††À †”À †˜À †ãÀ ‡À ‡2À ‡OÀ ‡jÀ ‡‰À ‡¨À ‡ÃÀ ‡ØÀ ˆ.À ˆVÀ ˆWÀ ˆ›À ˆ¡À ˆçÀ ‰,À ‰4À ‰5À ‰mÀ ‰sÀ ‰µÀ ‰äÀ ‰ëÀ ‰ìÀ Š6À Š^À ŠdÀ Š¯À ŠüÀ ‹EÀ ‹À ‹–À ‹ÆÀ ‹ÖÀ ‹ÜÀ Œ+À Œ_À ŒtÀ Œ~À ŒÀ ŒÏÀ ŒÜÀ ŒâÀ 0À mÀ sÀ šÀ  À òÀ BÀ À “À ÀÀ ÈÀ ÊÀ ËÀ ïÀ óÀ À À :À }À ºÀ ËÀ À À bÀ ÆÀ ÌÀ ‘À ‘LÀ ‘TÀ ‘UÀ ‘À ‘–À ‘àÀ ’0À ’ À ’¦À ’öÀ “À “$À “%À “hÀ “­À “ÒÀ “ØÀ ”'À ”˜À ”À ”îÀ •À •À •gÀ •‡À •‘À •“À •”À •¾À •ÂÀ –À –SÀ –WÀ –eÀ –iÀ –µÀ –ÁÀ –üÀ —:À —LÀ —‚À —ˆÀ —ñÀ —÷À ˜?À ˜À ˜›À ˜¡À ˜±À ˜·À ™À ™À ™gÀ ™ À ™©À ™ªÀ ™ßÀ ™åÀ šLÀ šRÀ ššÀ šêÀ šöÀ šüÀ ›À ›À ›`À ›qÀ ›zÀ ›{À ›ÉÀ ›ûÀ œÀ œhÀ œnÀ œ¶À À À À (À .À |À À –À ˜À ™À ÓÀ ×À îÀ -À BÀ “À ¡À ¢À èÀ Ÿ.À ŸUÀ Ÿ]À Ÿ^À Ÿ¢À ŸèÀ  /À  mÀ  wÀ  yÀ  zÀ  {À  ªÀ  ¶À  ÌÀ  ÒÀ ¡À ¡nÀ ¡tÀ ¡ÀÀ ¡ÖÀ ¢#À ¢|À ¢ÑÀ ¢êÀ ¢òÀ ¢óÀ £À £%À £~À £¯À £µÀ £õÀ £ûÀ ¤SÀ ¤®À ¤´À ¤ÄÀ ¤ÊÀ ¥&À ¥JÀ ¥VÀ ¥WÀ ¥vÀ ¥|À ¥ÈÀ ¥ÎÀ ¦!À ¦'À ¦nÀ ¦tÀ ¦ÉÀ ¦èÀ §?À §EÀ §UÀ §[À §£À §îÀ ¨À ¨|À ¨‰À ¨ŠÀ ¨ÖÀ ¨ÜÀ ©/À ©À ©ªÀ ©°À ªÀ ªOÀ ª¡À ªóÀ ªùÀ «IÀ «™À «çÀ ¬7À ¬}À ¬ƒÀ ¬“À ¬™À ¬çÀ ­À ­À ­À ­FÀ ­JÀ ­À ­¯À ­½À ­ìÀ ­ñÀ ®<À ®‡À ®ÖÀ ¯$À ¯sÀ ¯xÀ ¯ÈÀ °À °*À °/À °wÀ °xÀ °¬À °­À °ØÀ °ıÀ ±&À ±KÀ ±vÀ ±ŸÀ ±ÉÀ ±ùÀ ²&À ²PÀ ²„À ²´À ²àÀ ³À ³À ³JÀ ³€À ³¾À ³ôÀ ´6À ´tÀ ´´À µ À µFÀ µ†À µØÀ ¶"À ¶dÀ ¶œÀ ¶İÀ ·À ·À ·KÀ ·fÀ ·gÀ ·•À ·éÀ ·íÀ ·îÀ ¸À ¸?À ¸jÀ ¸¾À ¸¿À ¹À ¹À ¹)À ¹DÀ ¹ZÀ ¹`À ¹dÀ ¹eÀ ¹«À ¹¹À ¹¿À ¹×À ¹ğÀ º7À º;À º[À º«À ºÕÀ ºüÀ »@À »DÀ »EÀ »}À »­À »®À »çÀ »íÀ ¼À ¼À ¼#À ¼)À ¼oÀ ¼ À ¼èÀ ¼îÀ ½6À ½KÀ ½_À ½¨À ½ÔÀ ½ØÀ ½óÀ ¾À ¾DÀ ¾‚À ¾†À ¾‡À ¾¿À ¿ À ¿À ¿MÀ ¿SÀ ¿•À ¿æÀ À7À ÀXÀ À^À À«À ÀÌÀ ÀÒÀ ÀùÀ ÀÿÀ ÁÀ ÁÀ ÁdÀ Á˜À ÁâÀ ÁøÀ ÂÀ ÂaÀ ÂœÀ Â À ÂÃÀ ÂŞÀ ÃÀ ÃZÀ Ã^À Ã_À Ã£À Ã©À ÃÑÀ ÃíÀ Ä?À ÄCÀ ÄfÀ ÄÀ Ä¦À ÄäÀ ÄèÀ ÄéÀ Å#À ÅrÀ Å¯À ÅµÀ ÅòÀ ÆÀ ÆQÀ ÆUÀ ÆwÀ Æ’À Æ´À ÆúÀ ÆşÀ ÆÿÀ Ç@À ÇpÀ ÇvÀ Ç¨À ÇÄÀ ÈÀ ÈÀ È=À ÈXÀ È}À È¿À ÈÃÀ ÈÄÀ ÉÀ ÉÀ É\À É§À É­À ÉçÀ ÉíÀ ÊÀ ÊÀ ÊzÀ Ê€À ÊçÀ ÊíÀ ËTÀ ËZÀ Ë¦À Ë÷À ÌÀ Ì	À ÌÀ ÌÀ ÌnÀ ÌšÀ ÌãÀ Í"À Í@À Í”À Í˜À Í½À ÍØÀ ÍıÀ Î@À ÎDÀ ÎEÀ Î}À Î´À ÎµÀ Ï À ÏNÀ Ï™À ÏæÀ Ğ4À Ğ:À ĞÀ Ğ…À ĞÓÀ Ğ÷À ĞıÀ ÑfÀ ÑlÀ ÑÕÀ ÑÛÀ ÒDÀ ÒJÀ Ò–À ÒçÀ ÒóÀ ÒùÀ Ó	À ÓÀ ÓYÀ ÓtÀ Ó½À ÓİÀ Ô&À Ô*À ÔQÀ ÔlÀ ÔªÀ ÔõÀ ÔùÀ ÔúÀ ÕJÀ ÕˆÀ ÕÀ Õ²À ÕÑÀ ÖÀ Ö6À ÖKÀ ÖlÀ ÖŒÀ ÖçÀ ×.À ×9À ×?À ×PÀ ×TÀ ×zÀ ×“À ×åÀ Ø-À ØuÀ Ø‚À ØÏÀ ÙÀ ÙSÀ Ù¬À ÙıÀ ÚÀ ÚÀ ÚÀ ÚZÀ Ú®À ÚúÀ Û À Û(À ÛuÀ Û™À ÛóÀ Û÷À Ü"À Ü=À ÜbÀ Ü¨À Ü¬À Ü­À ÜçÀ ÜíÀ İ#À İ)À İ9À İ?À İ{À İ³À İåÀ Ş-À ŞDÀ ŞtÀ ŞxÀ Ş–À ŞÎÀ ŞÒÀ ŞÓÀ ßÀ ß,À ß2À ßWÀ ß]À ß®À ßÏÀ à&À àHÀ àLÀ àMÀ àuÀ à»À àÛÀ àùÀ á'À á/À á<À á‚À áˆÀ áŒÀ áÀ áÈÀ áÎÀ âÀ â/À â5À âCÀ âaÀ âgÀ â}À âƒÀ â°À âÊÀ âÛÀ âòÀ ã@À ãKÀ ãSÀ ã]À ãcÀ ãsÀ ãyÀ ã´À ãÕÀ ä,À äNÀ äRÀ äSÀ ä{À ä”À ä²À äàÀ äèÀ äõÀ å6À åŒÀ å·À åûÀ æÀ æ	À æÀ æÀ æMÀ æSÀ æŸÀ æéÀ çÀ ç4À ç{À çÀ ç À çêÀ çîÀ çïÀ èÀ èFÀ èJÀ èfÀ è«À è¯À è°À èèÀ èîÀ é:À é€À é³À é¹À éÿÀ ê À ê&À êsÀ ê¿À êâÀ êèÀ ë/À ë}À ë¤À ë¥À ë±À ëÇÀ ìÀ ì4À ì:À ìjÀ ì…À ì¡À ìÊÀ ìèÀ íÀ íBÀ íMÀ ípÀ í—À í¼À íèÀ î#À îxÀ î‡À î­À îµÀ îÍÀ îÓÀ îòÀ ï#À ï;À ïAÀ ïqÀ ï™À ï±À ï·À ïèÀ ğÀ ğ,À ğ2À ğQÀ ğÀ ğ¦À ğ¬À ğÊÀ ñÀ ñÀ ñ#À ñRÀ ñ“À ñ«À ñ±À ñËÀ ñşÀ òÀ òÀ ò;À òxÀ òÀ ò–À ò¬À òåÀ òöÀ ó*À óAÀ ó_À ócÀ óeÀ ófÀ ó¨À óÀÀ ôÀ ô[À ô£À ôíÀ õÀ õÀ õ!À õÀ õŠÀ õ‹À õ«À õ±À ö
À öÀ öÀ ö;À öAÀ ö‘À öÌÀ öİÀ öŞÀ öğÀ ööÀ ÷FÀ ÷”À ÷àÀ ø-À øvÀ ø|À øÍÀ øÙÀ øßÀ øïÀ øõÀ ùTÀ ù™À ù À ù¢À ù£À ùâÀ ùõÀ úCÀ ú“À ú©À úµÀ ú¶À ûÀ ûTÀ ûjÀ ûvÀ ûxÀ ûyÀ û¯À û³À ûóÀ û÷À üEÀ ü]À üaÀ ü°À üÿÀ ıFÀ ıÀ ıÜÀ ıêÀ ıîÀ ş:À ş‰À şĞÀ şÔÀ şâÀ şæÀ ÿTÀ ÿ£À ÿÉÀ À &À XÀ hÀ À £À ­À ÌÀ ĞÀ ÑÀ òÀÀ%À&ÀAÀBÀ†À™ÀšÀÜÀğÀñÀÀXÀ‰ÀÀàÀûÀÀLÀ—ÀæÀÀÀFÀrÀˆÀ¿ÀÔÀ÷ÀÀÀÀÀ^ÀdÀ²ÀÈÀãÀ÷ÀÀ#À6À@À®À²À³ÀèÀîÀ:ÀJÀPÀÀ¶ÀÀUÀŸÀëÀ	@À	mÀ	›À	ŸÀ	 À	ñÀ
À
À
YÀ
À
­À
½ÀÀ$À.ÀAÀEÀFÀwÀ}ÀÌÀÀlÀ¸ÀÀRÀÀ¼ÀÂÀÀ9À?À‡ÀØÀîÀôÀ*À0À>ÀYÀ_À—ÀÖÀõÀ?ÀPÀbÀ‚ÀÒÀ ÀFÀ|À‡À¨À°À¶ÀØÀÀWÀ‚ÀÅÀ	ÀFÀ_ÀeÀ¡ÀÑÀ×ÀôÀÀÀ6ÀTÀoÀwÀ}À™À¼ÀÂÀİÀãÀÀ?ÀIÀOÀzÀ‚ÀŒÀ’À×À%ÀIÀ[ÀpÀˆÀ³ÀÀRÀ”ÀÀ£ÀÂÀíÀñÀòÀ>À„ÀŠÀ×À!ÀqÀÀÀ
ÀWÀÀ‘ÀÀÇÀÉÀÊÀäÀÀ]ÀxÀ}ÀËÀíÀ	ÀÀÀ>À?ÀgÀhÀ½ÀóÀ1ÀaÀkÀsÀwÀxÀ´ÀÀÀ,À?ÀWÀcÀ{ÀÈÀàÀ*ÀbÀiÀÀÀ“À”À¾À¿ÀâÀãÀïÀ À !À "À TÀ À ‘À ÅÀ ÉÀ!À!À!#À!mÀ!¶À"À"JÀ"•À"¾À"ÂÀ"ûÀ"ÿÀ#À#À#NÀ#ŒÀ#ªÀ#÷À$BÀ$_À$«À$ÊÀ$ëÀ$ñÀ$ùÀ$ıÀ%À%À%#À%0À%gÀ%¥À%åÀ&$À&pÀ&ŠÀ&ÙÀ'!À'BÀ'HÀ'PÀ'bÀ'¬À'ÈÀ'ÎÀ(À((À(fÀ(gÀ(–À(œÀ(éÀ)À)À)À)/À)5À)}À)ƒÀ)ÏÀ)äÀ)æÀ)çÀ*À*À*SÀ*mÀ*qÀ*©À*ÆÀ*àÀ+À+À+]À+xÀ+}À+¶À+ÔÀ+ğÀ+ıÀ+şÀ,À,>À,yÀ,ªÀ,«À,ÊÀ,ùÀ,ÿÀ-3À-XÀ-¢À-İÀ-ŞÀ.À.À.PÀ.VÀ.§À.­À.îÀ/À/IÀ/‘À/åÀ0 À0uÀ0„À0¬À0èÀ1*À16À1>À1FÀ1_À1}À1ƒÀ1 À1¤À1¥À1áÀ2<À2=À2À2°À2ÙÀ2ÛÀ2ÜÀ2ÿÀ3À3RÀ3¢À3ğÀ4À4À4iÀ4·À4ğÀ4ôÀ5?À5‰À5ÙÀ6(À6tÀ6ÅÀ7À7\À7˜À7œÀ7æÀ80À8€À8¼À8ÀÀ9À9À9>À9RÀ9fÀ9{À9™À9¤À9ğÀ:À:&À:DÀ:dÀ:ˆÀ:À:À:À:³À:·À;À;VÀ;¤À;ÇÀ;ËÀ<À<mÀ<¦À<ªÀ<õÀ=?À=À=ŞÀ>*À>{À>ÊÀ?À?NÀ?RÀ?œÀ?æÀ@6À@rÀ@vÀ@ÃÀ@ÏÀ@şÀAÀA.ÀACÀAaÀAlÀA¸ÀAÑÀBÀB8ÀB>ÀB‚ÀBªÀB°ÀB´ÀBÈÀBîÀCÀC,ÀC1ÀC3ÀC4ÀC}ÀCÀCĞÀDÀDeÀD¯ÀDÜÀDŞÀDßÀEÀEdÀEÀE×ÀEôÀEöÀE÷ÀF4ÀF8ÀF†ÀFÑÀFéÀFíÀG9ÀGŠÀGÉÀGÍÀHÀHbÀH²ÀIÀIMÀIÀIíÀJ5ÀJqÀJuÀJ¿ÀK	ÀKYÀK•ÀK±ÀKÅÀKÒÀKàÀKöÀLÀL*ÀL>ÀLSÀLqÀLvÀL“ÀLÇÀLËÀLéÀMÀM#ÀM$ÀMLÀMqÀM¯ÀM¿ÀMÕÀMíÀN	ÀN&ÀN/ÀN0ÀNMÀN“ÀN½ÀNÇÀOÀO<ÀOFÀONÀOOÀO`ÀO{ÀOŸÀOÅÀOÏÀOíÀP1ÀPLÀPhÀPsÀP™ÀPµÀPÕÀPÖÀQÀQÀQÀQÀQÀQdÀQtÀQxÀQ¯ÀQÃÀRÀRÀRdÀR³ÀSÀS-ÀS3ÀSkÀSvÀSwÀS¹ÀS¿ÀTÀTaÀTgÀT ÀT«ÀT­ÀT®ÀTÒÀTÖÀTäÀTèÀU7ÀU]ÀUrÀU¦ÀU¬ÀUúÀVEÀV†ÀVŒÀVœÀV¢ÀVñÀWÀWÀWhÀWÀW”ÀWâÀX0ÀXJÀXPÀX`ÀX—ÀX¤ÀXïÀXõÀYCÀYÀYÃÀYÌÀZÀZPÀZVÀZ¤ÀZøÀZşÀ[À[KÀ[RÀ[†À[ŒÀ[ÚÀ\%À\fÀ\lÀ\|À\‚À\ËÀ\äÀ\ùÀ\ûÀ\üÀ]MÀ]gÀ]œÀ]æÀ^À^À^1À^2À^‚À^¥À^«À^ûÀ_DÀ_•À_ŞÀ_øÀ_şÀ`MÀ`™À`ÓÀaÀaÀaÀa7Àa;Àa€Àa„ÀaÇÀbÀbÀbÀbdÀbÀb“ÀbÒÀcÀc=ÀcAÀc…Àc¾ÀcØÀdÀd.ÀdJÀdgÀd˜Àd™ÀdçÀe,Àe8Àe9ÀeaÀegÀe´ÀfÀf&ÀfLÀfkÀf‚Àf†Àf·Àf¸ÀföÀfüÀgAÀg…ÀgÆÀgÇÀg÷Àh4Àh5ÀhjÀh¢Àh£ÀhëÀi5Ài6Ài}ÀiŠÀiÂÀiÃÀj
Àj<Àj†Àj‡ÀjÊÀk
ÀkÀkÀk€ÀkÃÀl
ÀlOÀl\ÀlÒÀlÓÀmÀm_ÀmnÀmÖÀm×ÀnÀncÀn¨Àn½Ào5Ào6Ào|ÀoÀÀpÀpLÀpqÀpÍÀpÎÀqÀqXÀqÀqäÀr*ÀrRÀr¾Àr¿ÀsÀs$Às*ÀsmÀs‘Às—ÀsŞÀtÀteÀt©ÀtğÀu4ÀubÀuhÀu­ÀuãÀv5ÀvUÀv´Àv¸ÀvüÀwWÀwXÀw§ÀwìÀwòÀxAÀxŠÀxÎÀxõÀxûÀyGÀy–ÀyâÀyèÀzÀz,ÀzGÀzbÀz}Àz„Àz¨ÀzÌÀ{À{6À{:À{}À{ÀÀ{ıÀ{şÀ{ÿÀ|NÀ|“À|™À|ÍÀ|ÓÀ}"À}pÀ}³À}ıÀ~À~MÀ~›À~èÀ~ÿÀ/ÀPÀkÀ†À¡À¨ÀÑÀõÀ€AÀ€yÀ€}À€ÈÀÀ>À{À|ÀÃÀÚÀöÀ‚À‚RÀ‚VÀ‚³À‚´À‚öÀƒ$Àƒ*Àƒ|ÀƒÊÀƒæÀ„À„BÀ„FÀ„£À„¤À„ìÀ…)À…hÀ…©À…ïÀ†3À†wÀ†ƒÀ†ÄÀ†äÀ‡7À‡;À‡€À‡ËÀ‡ÌÀˆÀˆ,Àˆ2ÀˆÀˆ¦Àˆ¬ÀˆóÀ‰(À‰DÀ‰vÀ‰zÀ‰ÇÀ‰ÈÀŠ
ÀŠMÀŠ]ÀŠ|ÀŠÀŠÂÀŠÆÀ‹À‹À‹IÀ‹OÀ‹œÀ‹êÀŒÀŒXÀŒ˜ÀŒ¼ÀŒ×ÀŒÿÀ>ÀKÀwÀ}ÀÀÉÀ9À:À€À¿ÀüÀÀOÀ ÀËÀÀUÀyÀ”À¼À‘À‘À‘AÀ‘GÀ‘KÀ‘¡À’À’À’cÀ’¤À’ÈÀ’ÉÀ“À“RÀ“mÀ“‘À“’À“âÀ”/À”NÀ”TÀ”œÀ”¢À”çÀ•À•*À•TÀ•XÀ••À•–À•ÖÀ–À–#À–GÀ–gÀ–À– À–¤À–ëÀ–ìÀ—,À—\À—„À—ªÀ—ÊÀ—éÀ—úÀ—şÀ˜LÀ˜MÀ˜‚À˜ˆÀ˜ØÀ™%À™pÀ™¯À™µÀšÀšUÀš§ÀšôÀ›>À›ŒÀ›šÀ›ßÀ›ôÀœÀœ]ÀœaÀœ•Àœ–ÀœâÀœõÀœûÀKÀ™ÀÓÀÀ7ÀRÀpÀ£À¶À¼ÀŸ3ÀŸ7ÀŸ{ÀŸ|ÀŸËÀŸüÀ À NÀ –À åÀ¡4À¡~À¡¶À¡¼À¢À¢TÀ¢À¢ÑÀ¢×À£'À£tÀ£ÄÀ¤À¤TÀ¤¡À¤ğÀ¥@À¥À¥•À¥ãÀ¦2À¦fÀ¦lÀ¦½À§À§CÀ§pÀ§tÀ§vÀ§wÀ§¹À§½À§ËÀ¨)À¨9À¨jÀ¨pÀ¨–À¨ÂÀ¨âÀ© À©À©FÀ©LÀ©¡À©ÍÀª
ÀªRÀªVÀªWÀªvÀª|ÀªÏÀ«À«,À«-À«ZÀ«`À«±À¬À¬À¬6À¬7À¬gÀ¬mÀ¬½À­À­(À­.À­|À­ËÀ®À®hÀ®yÀ®¾À®÷À®ùÀ®úÀ¯BÀ¯FÀ¯—À¯ãÀ°)À°-À°sÀ°wÀ°ÃÀ±À±0À±4À±~À±ÎÀ±ïÀ²/À²^À²¥À²¦À²ÎÀ²ÏÀ²ÛÀ³À³À³À³_À³yÀ³´À³şÀ³ÿÀ´À´7À´8À´DÀ´_À´’À´³À´ËÀµ.ÀµŠÀµşÀ¶À¶À¶'À¶+À¶,À¶8À¶LÀ¶sÀ¶£À¶¶À¶¼À¶ÔÀ¶æÀ¶êÀ¶ìÀ¶íÀ·,À·0À·xÀ·ÃÀ¸À¸5À¸9À¸‡À¸ÖÀ¹"À¹rÀ¹ÀÀ¹ÎÀ¹áÀ¹ÿÀºÀº]ÀºŸÀºÒÀºÓÀ»	À» À»!À»FÀ»LÀ»šÀ»àÀ¼0À¼OÀ¼fÀ¼gÀ¼’À¼˜À¼èÀ½/À½}À½ÌÀ¾À¾À¾YÀ¾©À¾øÀ¿1À¿KÀ¿LÀ¿kÀ¿lÀ¿mÀ¿½À¿äÀ¿êÀÀ9ÀÀ†ÀÀÀÀ¤ÀÀÙÀÀßÀÁ%ÀÁWÀÁ˜ÀÁœÀÁÀÁæÀÁìÀÂ.ÀÂrÀÂÀÀÃÀÃ!ÀÃ"ÀÃ.ÀÃ—ÀÃ™ÀÃšÀÃĞÀÃşÀÄ#ÀÄ'ÀÄzÀÄ{ÀÄŸÀÅÀÅ7ÀÅ;ÀÅ~ÀÅÀÅÃÀÆ9ÀÆ|ÀÆ·ÀÆÓÀÆæÀÆóÀÇ	ÀÇ/ÀÇTÀÇ]ÀÇcÀÇgÀÇÃÀÇÄÀÈ$ÀÈšÀÈºÀÉÀÉÀÉ#ÀÉ±ÀÉ²ÀÉÖÀÊLÀÊpÀÊtÀÊ¶ÀÊ·ÀÊâÀÊçÀË<ÀËfÀË~ÀËªÀËºÀË×ÀËİÀËîÀËòÀÌ0ÀÌ1ÀÌ}ÀÌƒÀÌÄÀÌäÀÌæÀÌçÀÍÀÍXÀÍiÀÍ¡ÀÍ¢ÀÍïÀÎ2ÀÎ<ÀÎ=ÀÎ‹ÀÎ×ÀÏÀÏÀÏÀÏ\ÀÏ­ÀÏğÀÏùÀÏúÀĞJÀĞXÀĞaÀĞcÀĞdÀĞ±ÀÑÀÑÀÑÀÑhÀÑ{ÀÑÆÀÑÌÀÒ ÀÒÀÒWÀÒ]ÀÒ¬ÀÒúÀÓJÀÓ[ÀÓaÀÓ°ÀÓ¶ÀÓÜÀÓâÀÓòÀÓøÀÔEÀÔ^ÀÔoÀÔ€ÀÔÀÔ¼ÀÔ½ÀÔ×ÀÔîÀÔïÀÕ%ÀÕpÀÕšÀÕĞÀÕÑÀÕİÀÖ ÀÖÀÖAÀÖdÀÖhÀÖiÀÖuÀÖ¨ÀÖ©ÀÖµÀ×À×À×	À×ZÀ×©À×÷ÀØCÀØtÀØxÀØÁÀØÎÀØùÀÙFÀÙ—ÀÙÛÀÙáÀÚ2ÀÚ€ÀÚ­ÀÚèÀÛ ÀÛ ÀÛ8ÀÛTÀÛUÀÛ£ÀÛéÀÛïÀÜ:ÀÜbÀÜhÀÜvÀÜ¥ÀÜÔÀİÀİ2ÀİaÀİkÀİqÀİÀÀŞÀŞÀŞÀŞ\ÀŞsÀŞŠÀŞ¡ÀŞ¸ÀŞÂÀŞÌÀŞÒÀŞäÀŞêÀßÀßÀßÀßYÀßuÀß‘Àß­ÀßÉÀßÓÀßİÀßãÀàjÀàpÀàzÀà·ÀàÚÀàıÀá ÀáCÀáMÀáWÀá]ÀáæÀáìÀáöÀâ7Àâ]ÀâƒÀâ©ÀâÏÀâÙÀâãÀãÀã*ÀãEÀã_Àã}Àã~ÀãÊÀãÚÀäÀäÀä4ÀäLÀäuÀävÀäÄÀäßÀåÀåÀå9ÀåQÀåzÀå{Àå’Àå±ÀåĞÀåãÀåäÀæÀæRÀæ–ÀæßÀç(Àç)ÀçJÀçVÀç£Àç¤ÀçÍÀçâÀçùÀè-ÀèDÀèNÀèvÀèÀè®ÀèÅÀèÏÀéÀéFÀéjÀéŸÀéÃÀéøÀêÀêIÀêOÀêSÀêTÀê`ÀêƒÀê­ÀêÁÀêáÀëÀë8ÀëZÀë…Àë‰ÀëŠÀë–ÀìÀìÀìÀì5ÀìJÀìaÀìšÀì³ÀìâÀíÀí8Àí\ÀíÀíÀíÂÀíÈÀíÌÀíÍÀíÙÀíïÀîÀîÀîTÀîmÀîœÀîÀÀîòÀïÀïHÀïWÀïôÀïúÀïşÀğ ÀğÀğ?ÀğCÀğ“ÀğŞÀñ0ÀñFÀñ|ÀñÀñ½ÀñõÀò	ÀòJÀòNÀòOÀòsÀò’ÀòÌÀòàÀóÀóÀóLÀókÀó°ÀóÄÀóâÀóæÀóçÀôÀô5ÀôzÀôÀô¬Àô°Àô±ÀôÿÀõ%ÀõBÀõCÀõ{ÀõÅÀöÀöYÀö¥Àö§Àö¨ÀöÛÀößÀöíÀöñÀ÷@À÷À÷ÜÀøÀøPÀø{Àø˜ÀøÔÀùCÀù_Àù{Àù™ÀùòÀùöÀù÷ÀúDÀúŠÀúÙÀúöÀûÀûVÀûZÀû[ÀûŸÀûñÀü?Àü\ÀüyÀü»Àü¿ÀüÀÀıÀı
ÀıXÀı¢ÀıÔÀş Àş=Àş`Àş~Àş¼ÀÿÀÿ"Àÿ#ÀÿmÀÿsÀÿÂÀÿùÀ À zÀ §À ïÀ óÀ ôÀEÀ’À¹ÀºÀÀ;À[À]À^ÀÀÛÀÜÀöÀÀÀ=ÀÀÀÄÀÅÀÑÀÀÀ!ÀeÀfÀrÀ•À¿ÀÓÀúÀ*À\À`ÀaÀmÀµÀ·À¸ÀğÀTÀUÀlÀƒÀÀŸÀ³ÀõÀÀ8À9ÀTÀkÀ–ÀÃÀôÀÀ%À)À*À6À€ÀÀÀØÀÙÀåÀ	À	2À	FÀ	sÀ	•À	·À	ŞÀ	âÀ	ãÀ	ïÀ
"À
$À
%À
WÀ
ŸÀ
 À
¸À
ĞÀ
ÑÀÀ!ÀXÀYÀeÀ¥À¦À²ÀóÀôÀ À#ÀMÀaÀˆÀ¬ÀÑÀÕÀÖÀâÀÀÀÀKÀ’À“À«ÀÃÀÄÀÀÀJÀKÀWÀ–À—À£ÀãÀäÀğÀÀ=ÀQÀwÀ›ÀÀÀÄÀÅÀÑÀÀÀÀ;ÀŒÀÀ®ÀÏÀĞÀíÀ3À?ÀvÀwÀƒÀíÀîÀúÀPÀQÀ]À€ÀªÀ¾ÀæÀÀ?ÀCÀDÀPÀÀÀÀÏÀÓÀ#ÀvÀºÀğÀ(À)ÀeÀšÀ¸ÀûÀÀSÀWÀ³À´ÀÀGÀxÀ–ÀÙÀíÀÀ"ÀvÀwÀ»ÀÀ<ÀZÀÀ±ÀáÀåÀ7À8À|À‚ÀĞÀÀKÀiÀ¬ÀÎÀÀ ÀZÀ^ÀºÀ»ÀíÀ À>ÀÀ•ÀÛÀ ÀÀ\À]ÀÀÄÀâÀ%À9ÀÀåÀ À #À ”À âÀ!À!%À!'À!(À!nÀ!£À!ÓÀ"À"9À"UÀ"cÀ"eÀ"fÀ"»À"ÔÀ"ØÀ#%À#sÀ#ÀÀ$À$À$iÀ$½À%À%nÀ%ÁÀ%êÀ%îÀ&HÀ&mÀ&qÀ&À&ƒÀ&ÇÀ'À'aÀ'‹À'ÕÀ(À(DÀ(‘À(ßÀ(ùÀ)4À)DÀ)À)¤À)ğÀ*6À*<À*”À*´À*ºÀ+À+€À+âÀ+ëÀ+ìÀ,=À,CÀ,›À,ùÀ-%À-+À-…À-âÀ-èÀ.NÀ.´À/À/%À/&À/yÀ/À/×À0/À0…À0 À0¦À1 À1VÀ1kÀ1qÀ1ÕÀ29À2œÀ2¦À2§À2çÀ2íÀ3GÀ3¢À3²À3¸À4À41À47À4šÀ4ıÀ5_À5hÀ5jÀ5kÀ5œÀ5ÄÀ5öÀ6À6>À6OÀ6QÀ6RÀ6†À6 À6ÈÀ7À7+À7IÀ7lÀ7À7³À7ÒÀ7ñÀ7õÀ8À8À8	À8FÀ8hÀ8ŠÀ8·À8ĞÀ8éÀ9À9À9,À9.À9/À9wÀ9{À9ÍÀ9àÀ9äÀ9òÀ9öÀ:lÀ:pÀ:À:‘À:ÆÀ:ÇÀ:üÀ;À;QÀ;¢À;ìÀ<!À<'À<vÀ<¬À<²À=À=xÀ=ÜÀ>BÀ>HÀ>“À>ÙÀ>ôÀ>úÀ?GÀ?šÀ?ÚÀ?íÀ?şÀ@À@'À@EÀ@mÀ@‡À@¬À@ÏÀ@îÀAÀAKÀA^ÀA‹ÀAÏÀBÀBtÀBˆÀBãÀBçÀC~ÀCÀCÊÀCêÀCğÀD?ÀDÀDÚÀEÀEÀEcÀE™ÀEŸÀFÀFeÀFÉÀG/ÀG5ÀG†ÀGÌÀGçÀGíÀH:ÀHÀHÍÀHÓÀIÀImÀI·ÀJÀJTÀJyÀJŒÀJŸÀJ²ÀJÌÀJêÀKÀK,ÀK?ÀK\ÀKƒÀK¢ÀKÃÀKÿÀLÀL?ÀL|ÀLäÀLåÀMJÀM¦ÀMêÀN ÀNjÀNwÀNàÀNöÀO‚ÀOˆÀOŒÀP;ÀQ#ÀQ$ÀQtÀQ’ÀQ˜ÀQãÀR1ÀRlÀRrÀRÁÀSÀS\ÀS‘ÀS—ÀSçÀT(ÀT.ÀTÀTòÀUUÀUºÀUÀÀVÀV_ÀV‚ÀVˆÀVÕÀW(ÀWhÀWzÀWÀW§ÀWÅÀWíÀX
ÀX-ÀXGÀXnÀXÀX®ÀXÑÀXòÀYÀYTÀYgÀY”ÀYÑÀZ9ÀZMÀZÂÀZÆÀ[‡À[ˆÀ[ÚÀ[øÀ\À\nÀ\{À\©À]À]À]À]À]À]PÀ]sÀ]ÃÀ^À^[À^¬À^ûÀ_PÀ_zÀ_–À_äÀ`À`À`OÀ`hÀ`À`À`®À`ÌÀa
ÀaÀa‘ÀaªÀaÈÀaÎÀaÒÀb
Àb”Àb–Àb—ÀcÀcÀcAÀc†ÀcŠÀdÀdÀd?Àd@Àd„ÀdŠÀdØÀe'ÀeQÀeWÀeÓÀfÀfCÀfbÀfÀf†ÀfÙÀg.Àg›ÀgŸÀg Àg¼ÀgÒÀgñÀhÀhÀh)Àh_ÀhlÀh‹Àh’ÀhµÀhèÀiÀiÀiÀi;Ài[Ài\Ài˜ÀiâÀiãÀj.ÀjHÀjNÀj™ÀjÍÀjÓÀkÀk^ÀkdÀkµÀkÿÀl8Àl>ÀlqÀlwÀlÀl®ÀlÚÀmÀm4Àm>ÀmDÀm“ÀmÜÀmâÀn@ÀnFÀnqÀnwÀn‚Àn’Àn¥ÀnàÀnæÀoAÀo„ÀoŠÀo½ÀoÃÀoÍÀoşÀp/Àp9Àp?ÀpˆÀp”ÀpšÀpåÀq"Àq4ÀqTÀq|ÀqƒÀq¤ÀqÛÀqáÀrÀr2Àr¦Àr¬ÀsÀs_ÀseÀsˆÀs±Às¾ÀsùÀsÿÀt3ÀtxÀt­ÀtÀÀtÄÀtÅÀtÕÀtñÀuÀu7Àu\Àu^Àu_ÀuyÀu ÀuéÀvÀvÀvIÀv\ÀvoÀvˆÀv£Àv´ÀvµÀv×ÀvûÀw'Àw(Àw4ÀwWÀwwÀwŠÀw´ÀwÈÀwìÀxÀxWÀx¦ÀxªÀx«Àx·Ày&Ày(Ày)ÀyzÀy~Ày¡ÀyèÀyúÀzBÀzOÀzPÀzÀz¯Àz°À{À{À{!À{"À{ZÀ{ŒÀ{ÓÀ{ÙÀ|À|bÀ|hÀ|¹À|âÀ|èÀ}#À}LÀ}‚À}ÍÀ}ÓÀ~ À~JÀ~À~›À~°À~ÎÀ~ôÀÀ%ÀBÀeÀºÀ€À€NÀ€™À€ìÀHÀIÀÀßÀ‚À‚À‚NÀ‚oÀ‚}À‚´À‚ÙÀ‚çÀ‚èÀƒVÀƒ˜ÀƒœÀƒÀƒíÀ„!À„]À„—À„ØÀ„ŞÀ…À…À…[À… À…»À…ÁÀ†À†[À†nÀ†©À†ÒÀ‡À‡SÀ‡YÀ‡ªÀ‡õÀˆÀˆÀˆOÀˆyÀˆ¾ÀˆÎÀˆãÀ‰ À‰%À‰<À‰UÀ‰rÀ‰•À‰êÀŠAÀŠ‚ÀŠÍÀ‹ À‹|À‹}À‹ÏÀŒÀŒÀŒÀŒ9ÀŒPÀŒtÀŒ¢ÀŒÂÀŒüÀŒşÀŒÿÀMÀQÀrÀ¶ÀÇÀéÀïÀ=À‡ÀÀÀÆÀÀbÀxÀ‚ÀƒÀ½ÀÃÀ	ÀÀQÀgÀpÀqÀ¦À¬ÀîÀ‘À‘À‘À‘À‘\À‘hÀ‘lÀ‘‹À‘™À‘ÑÀ‘ßÀ‘àÀ’À’&À’(À’)À’^À’bÀ’©À’íÀ“.À“2À“{À“ËÀ”À”1À”5À”…À”ÎÀ•À•À•TÀ•“À•ÃÀ–À–$À–*À–sÀ–»À—À—ZÀ—§À—êÀ—ğÀ˜7À˜MÀ˜iÀ˜½À˜ÛÀ™8À™RÀ™qÀ™À™êÀ™îÀšÀš=Àš]ÀšÀš¿ÀšÀÀ›À›zÀ›¿À›İÀ›ŞÀœ&Àœ,ÀœXÀœ^ÀœnÀœtÀœÅÀœúÀÀÀpÀÁÀÀYÀhÀnÀºÀŸÀŸYÀŸ¡ÀŸïÀ 9À ?À ŒÀ ’À ¶À ¼À¡
À¡VÀ¡¦À¡öÀ¢À¢!À¢oÀ¢¸À£	À£WÀ£¥À£õÀ¤=À¤jÀ¤pÀ¤ºÀ¤ÓÀ¤ÙÀ¤çÀ¥À¥<À¥SÀ¥“À¥¼À¥óÀ¦,À¦FÀ¦`À¦hÀ¦rÀ¦xÀ¦ÇÀ§À§cÀ§À§‡À§•À§ÂÀ¨À¨-À¨DÀ¨„À¨»À¨ôÀ©À©À© À©&À©wÀ©½ÀªÀªÀªÀªHÀª_Àª³ÀªìÀ«À«À«~À«·À«ÑÀ«ÙÀ«ãÀ«éÀ¬4À¬}À¬ÎÀ­À­À­0À­6À­uÀ­{À­ÉÀ®À®hÀ®³À¯À¯PÀ¯›À¯æÀ°7À°ˆÀ°£À°©À°¹À°¿À±À±1À±yÀ±À±½À±ØÀ±òÀ².À²;À²_À²¦À²ÕÀ²ÛÀ²ßÀ³/À³]À³|À³šÀ³ºÀ³ÛÀ´
À´KÀ´LÀ´ŒÀ´«À´±À´ğÀ´öÀµDÀµˆÀµ²Àµ³ÀµöÀ¶;À¶‚À¶·À¶½À¶âÀ·À·À·fÀ·¶À·øÀ·ùÀ¸HÀ¸’À¸£À¸©À¸ïÀ¹À¹@À¹AÀ¹|À¹}À¹ÒÀºÀº	ÀºZÀº¦ÀºõÀ»À»VÀ»WÀ»§À»âÀ¼
À¼'À¼EÀ¼ƒÀ¼œÀ¼ À¼âÀ¼ãÀ½6À½ŒÀ½¨À½®À¾ À¾NÀ¾À¾ËÀ¾êÀ¿À¿7À¿KÀ¿OÀ¿—À¿˜À¿æÀ¿ıÀÀÀÀGÀÀMÀÀŸÀÀçÀÁÀÁÀÁ`ÀÁtÀÁĞÀÁğÀÂÀÂ-ÀÂ…ÀÂ‰ÀÂ§ÀÂÄÀÂãÀÃÀÃ ÀÃ]ÀÃ^ÀÃ¬ÀÃËÀÃÑÀÄÀÄÀÄmÀÄµÀÅÀÅ@ÀÅbÀÅƒÀÅµÀÅ¹ÀÆÀÆÀÆZÀÆnÀÆtÀÆ¸ÀÆ¾ÀÇÀÇXÀÇÀÇ¹ÀÇùÀÈÀÈ<ÀÈ@ÀÈˆÀÈ‰ÀÈÚÀÉ,ÀÉÀÉÀÉ–ÀÉêÀÊ=ÀÊÀÊŞÀË-ÀË€ÀËÓÀÌ"ÀÌsÀÌÀÌ•ÀÌÍÀÍÀÍsÀÍÂÀÎÀÎ
ÀÎXÀÎÀÎ…ÀÎ“ÀÎ¬ÀÎæÀÏ$ÀÏ=ÀÏxÀÏµÀÏ¿ÀÏÅÀĞÀĞbÀĞ¸ÀÑÀÑÀÑ"ÀÑhÀÑµÀÑéÀÑïÀÒ?ÀÒÀÒÚÀÒòÀÓÀÓ%ÀÓTÀÓuÀÓ»ÀÓ¿ÀÔÀÔÀÔdÀÔ¶ÀÕ	ÀÕÀÕ_ÀÕ±ÀÖÀÖQÀÖ£ÀÖ÷À×JÀ×WÀ×]À×’À×¶À×åÀØÀØRÀØVÀØµÀØ¶ÀØùÀÙEÀÙbÀÙ—ÀÙ²ÀÙÑÀÙÿÀÚÀÚJÀÚKÀÚšÀÚâÀÚèÀÛ6ÀÛkÀÛ‹ÀÛ«ÀÛÆÀÜÀÜÀÜ.ÀÜJÀÜfÀÜ‚ÀÜ°ÀÜïÀÜğÀİÀİ%ÀİjÀİ…Àİ¥ÀİÀÀİíÀİñÀŞOÀŞPÀŞ ÀŞÛÀßÀß%Àß@Àß|Àß¨Àß¬ÀßÊÀßçÀàÀà&ÀàTÀà“Àà”ÀàåÀá'ÀáTÀávÀá‘ÀáÓÀá×ÀáüÀâ+ÀâlÀâmÀâ½ÀãÀã3Àã9Àã~Àã¹ÀãÛÀãıÀäÀäpÀätÀäšÀäÀÀäğÀå3Àå4ÀåÀåÒÀåõÀæÀæ?ÀæZÀæ–ÀæÂÀæÆÀæäÀçÀç Àç@ÀçnÀç­Àç®ÀçùÀèKÀèšÀè½Àè÷ÀéÀé1ÀésÀéwÀé”Àé±ÀéÓÀêÀêFÀêGÀêƒÀê‰ÀêÉÀëÀë`Àë´ÀìÀìUÀìÀì‡ÀìßÀí>Àí^ÀíyÀíÀÀîÀîÀî#Àî?Àî]Àî|ÀîŸÀîÂÀîâÀïÀïLÀïMÀï‚ÀïˆÀïÑÀğÀğFÀğpÀğ°ÀğËÀğıÀñÀñÀñKÀñŠÀñ‹ÀñÙÀò0ÀòlÀò®ÀòÒÀòíÀóoÀóˆÀóÖÀóÜÀóàÀôÀô"ÀôAÀôsÀôœÀôäÀôåÀõ4Àõ€Àõ†ÀõÕÀõîÀõôÀö@Àö‰ÀöœÀöáÀ÷#À÷BÀ÷aÀ÷|À÷³À÷æÀøÀøLÀøÀø´ÀøæÀùÀùOÀùˆÀù¾ÀúÀúÀújÀúpÀútÀú›ÀúÄÀúìÀûÀûAÀûjÀû’Àû¼ÀûçÀüÀüJÀüšÀü›ÀüâÀüèÀı6Àı„ÀıÑÀşÀşaÀşgÀşµÀÿÀÿPÀÿ—Àÿ¨ÀÿğÀ 2À TÀ sÀ À ÅÀ ûÀ0ÀgÀŸÀÒÀÀ8ÀmÀ¦ÀÜÀ!À:ÀˆÀÀ’À¹ÀåÀÀ=ÀkÀ”À¼ÀæÀÀGÀtÀÄÀÅÀÀ%ÀKÀ‘À¬À°ÀòÀóÀ?ÀOÀUÀ À­À³ÀÿÀLÀŠÀÀßÀ	+À	1À	‚À	ÏÀ
À
"À
lÀ
¸ÀÀ@À_ÀƒÀ¨ÀÚÀŞÀßÀ$À*ÀqÀwÀ‡ÀÀİÀöÀAÀ`À|À—ÀğÀôÀõÀ:À@ÀÀİÀãÀóÀùÀGÀeÀ²ÀÑÀíÀÀ(ÀsÀºÀ¾À¿ÀïÀÀ8À{À|À¯ÀµÀúÀ<ÀŠÀÂÀÀLÀmÀ’ÀâÀÀÀDÀJÀZÀ«À÷ÀÀpÀ»À¼ÀÀÀ>À‰ÀÀµÀÙÀÀRÀSÀ—ÀÀîÀGÀšÀîÀ&À,À|ÀÍÀÀnÀ¾ÀÀ^ÀdÀµÀÀZÀ±ÀáÀ5ÀƒÀÇÀÍÀ ÀoÀºÀÀ]ÀcÀ·À À QÀ WÀ ¨À ÃÀ ÉÀ ×À ìÀ ÿÀ!À!/À!7À!=À!kÀ!ÄÀ!âÀ"À"	À"À"JÀ"kÀ"¢À"ĞÀ"úÀ#À#5À#rÀ#À#®À#ôÀ$ À$LÀ$]À$rÀ$ À$ãÀ%
À%À%À%&À%.À%8À%>À%—À%À%«À%ÀÀ%ÓÀ%ëÀ&À&À&/À&7À&=À&kÀ&ÄÀ&âÀ'À'	À'À'JÀ'kÀ'¢À'ĞÀ'úÀ(%À(AÀ(~À(œÀ(ºÀ) À),À)XÀ)iÀ)~À)¬À)ïÀ*À*3À*gÀ*“À*À*£À*¯À*·À*ÁÀ*ÇÀ+À+[À+À+”À+¤À+ªÀ+øÀ,À,-À,\À,À,¥À,ÌÀ,íÀ-À-OÀ-oÀ-ŠÀ-ÍÀ-èÀ-éÀ.À.9À.„À.ÏÀ/7À/8À/À/¾À/¿À/éÀ0	À0.À0SÀ0xÀ0®À0ĞÀ0òÀ1(À1^À1’À1ÆÀ1ìÀ2À28À2`À2fÀ2gÀ2ĞÀ3À3IÀ3JÀ3pÀ3ÏÀ4À4À4À46À4„À4ŠÀ4À4À4ÓÀ4ÙÀ5*À5ƒÀ5ÖÀ6*À6|À6ÎÀ7À7À7[À7£À7©À7úÀ8:À8eÀ8kÀ8¹À9À9	À9UÀ9¢À9òÀ9øÀ:SÀ:dÀ:jÀ:xÀ:À: À:¸À:ĞÀ:ØÀ:ŞÀ;À;eÀ;ƒÀ;¤À;ªÀ;¼À;ëÀ<;À<ŠÀ<ÛÀ<÷À=<À=†À=¾À=úÀ>#À>JÀ>zÀ>¢À>¨À?À?\À?¶À?øÀ@$À@PÀ@À@ÊÀ@ÖÀ@÷ÀARÀA\ÀAbÀAnÀAvÀA€ÀA†ÀAßÀAåÀAóÀBÀBÀB3ÀBKÀB^ÀBwÀBÀB…ÀB³ÀCÀC*ÀCKÀCQÀCcÀC’ÀCâÀD1ÀD‚ÀDÀDãÀE-ÀEkÀE£ÀEßÀFÀF/ÀF_ÀF‡ÀFÀFèÀG?ÀGšÀG÷ÀHBÀHˆÀH±ÀHËÀIÀI"ÀI>ÀI‚ÀI¬ÀIÖÀIåÀJÀJSÀJˆÀJ½ÀJÃÀKÀKwÀKÏÀLÀLEÀLQÀLrÀLİÀLçÀLíÀLùÀMÀMÀMÀM!ÀM'ÀMtÀM‰ÀMªÀMÙÀN ÀN'ÀNQÀNuÀN˜ÀNÚÀNıÀOÀOIÀOdÀOeÀOÀO¸ÀPÀP"ÀP€ÀPºÀQ3ÀQkÀQlÀQ’ÀQçÀR1ÀR8ÀR9ÀRRÀR ÀR¦ÀRªÀR«ÀRİÀSÀS3ÀSVÀS†ÀS®ÀSÖÀSúÀTAÀTBÀTÀT•ÀTåÀTúÀU ÀU&ÀU~ÀU¾ÀUÙÀVÀVFÀVJÀVhÀV†ÀV«ÀVôÀVöÀV÷ÀW?ÀWCÀWwÀW{ÀWÂÀXÀXFÀX`ÀX‘ÀXÛÀX÷ÀXıÀY3ÀYOÀY^ÀY_ÀY‰ÀYÀYŞÀZ-ÀZvÀZ§ÀZ¿ÀZâÀ[À[,À[|À[™À[³À[ÄÀ\À\À\À\À\"À\ƒÀ\„À\ÔÀ\÷À]
À]"À]2À]JÀ]]À]gÀ]wÀ]{À]|À]¨À]©À]ªÀ]ÄÀ^
À^À^^À^tÀ^À^£À^³À^ÏÀ^âÀ^ìÀ_\À_`À_aÀ_ªÀ_°À`À`3À`vÀ`xÀ`yÀ`ÀÀ`ÄÀa	ÀaNÀa‡ÀaÈÀbÀb+ÀbGÀboÀb«Àb¬ÀbçÀbíÀc1ÀcxÀc¯ÀcôÀd0Àd[Àd\Àd‹Àd‘ÀdÜÀe,ÀeqÀeŒÀe¥ÀeéÀfÀf.ÀfMÀfaÀfuÀfyÀfzÀfÊÀfËÀfŞÀfàÀfáÀföÀfúÀg6ÀgEÀg_ÀgeÀg°ÀgûÀhÀhÀh\ÀhbÀh±ÀhÊÀhÛÀi	Ài(ÀiCÀi€Ài¿ÀjÀjÀjEÀjiÀj“Àj¾ÀjåÀkÀk6Àk7ÀkgÀkmÀk¿ÀkâÀk÷ÀkøÀl7Àl=Àl‹Àl×ÀmÀm0Àm1ÀmƒÀmÀmŸÀmÑÀm×Àn
ÀnÀn=Àn°ÀnæÀoÀoÀoÀo[ÀoaÀo”ÀoĞÀoÑÀpÀp$ÀpaÀp°Àp×ÀpİÀq!ÀqjÀq¹ÀqÛÀqïÀrÀrÀr[Àr_Àr`Àr²ÀrÀÀràÀróÀsÀs&ÀsMÀsTÀsXÀsYÀs‰ÀsÀsÚÀtÀtCÀtIÀtoÀt¼ÀuÀuQÀuÀuëÀv;ÀvˆÀvÌÀvÒÀw!ÀwAÀwVÀwÀw¥ÀwºÀwÑÀwæÀwõÀxÀxÀx+ÀxBÀx]ÀxlÀxƒÀx¶ÀxíÀy/Ày:ÀyBÀyHÀyLÀyMÀy†ÀyŒÀyÔÀyÚÀyıÀzKÀzbÀz‚Àz•Àz«ÀzÁÀzíÀ{(À{VÀ{…À{ºÀ{áÀ|À|7À|JÀ|NÀ|OÀ|[À|~À|À|±À|ÌÀ|ìÀ}À}9À}=À}>À}JÀ}ˆÀ}‰À}ÕÀ~'À~CÀ~}À~–À~°À~±À~îÀ$À%À?ÀŒÀ¾À€À€xÀ€œÀ€¸À€ïÀ€ğÀ+ÀtÀuÀ®ÀİÀŞÀ‚À‚FÀ‚GÀ‚˜À‚ÔÀ‚üÀƒÀƒ
ÀƒÀƒ#Àƒ'Àƒ(Àƒ4ÀƒwÀƒyÀƒzÀƒÁÀƒÅÀ„À„*À„cÀ„†À„‡À„ÕÀ„êÀ…+À…pÀ…¢À…ÈÀ…æÀ…êÀ…ëÀ†%À†+À†dÀ†¢À†çÀ‡0À‡zÀ‡§À‡ïÀˆ*Àˆ[Àˆ—ÀˆĞÀˆÔÀˆÕÀ‰+À‰,À‰—À‰˜À‰ÌÀ‰éÀ‰øÀ‰ùÀŠÀŠÀŠBÀŠHÀŠ™ÀŠ´ÀŠÌÀŠÜÀŠıÀ‹À‹À‹/À‹3À‹4À‹„À‹§À‹­À‹úÀŒDÀŒ‘ÀŒŞÀ,ÀJÀ]ÀmÀŒÀ©À¼ÀÆÀÖÀÚÀÛÀÀÀÀ]ÀaÀ°ÀÈÀÀÀÀdÀ§ÀãÀÀMÀmÀqÀàÀáÀ‘À‘ À‘pÀ‘ÂÀ‘ÜÀ‘âÀ’0À’ƒÀ’ÄÀ“À“À“6À“NÀ“gÀ“zÀ“ À“§À“»À“ÑÀ”À”.À”|À”€À•À• À•/À•aÀ•‹À•‘À•ÌÀ•÷À•øÀ–À–<À–gÀ–mÀ–¨À–ÖÀ–×À–îÀ—0À—bÀ—hÀ—ŸÀ—âÀ—ãÀ˜3À˜VÀ˜‰À˜ŠÀ˜ØÀ˜ôÀ˜úÀ™EÀ™’À™£À™©À™÷ÀšÀšoÀš¢Àš¼ÀšÂÀš÷À›À›À›À›PÀ›kÀ›ˆÀ›ÆÀœÀœ(ÀœfÀœ‡Àœ½ÀœÃÀœäÀÀÀ*ÀeÀwÀ{ÀòÀôÀõÀ*ÀZÀ[À“À—ÀáÀîÀŸ1ÀŸ2ÀŸ‚ÀŸ˜ÀŸœÀŸêÀ À À YÀ ]À pÀ tÀ €À µÀ ¹À ôÀ¡,À¡2À¡6À¡VÀ¡‡À¡À¡•À¡ğÀ¢LÀ¢~À¢²À¢èÀ£/À£sÀ£°À£ÄÀ£ğÀ¤À¤À¤DÀ¤SÀ¤“À¤›À¤¨À¤ÅÀ¤ËÀ¤ÑÀ¤áÀ¤öÀ¥À¥-À¥/À¥0À¥À¥«À¥¯À¥ÿÀ¦OÀ¦„À¦¿À§À§À§:À§RÀ§SÀ§¥À§ÀÀ§ÁÀ§ÍÀ§ãÀ¨=À¨VÀ¨nÀ¨µÀ¨ŞÀ¨äÀ©À©À©  dart.ui€¾ B_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaintImageByteFormatPixelFormatImage_Image	FrameInfoCodecinstantiateImageCodecinstantiateImageCodecFromBufferdecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayerPathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgram_FragmentShader
VertexModeVertices	PointModeClipOpCanvasPicturePictureRecorderShadowImmutableBufferImageDescriptor	_futurizePictureRasterizationException ßä